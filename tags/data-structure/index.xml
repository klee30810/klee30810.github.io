<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure on Kevin&#39;s Codex</title>
    <link>https://klee30810.github.io/tags/data-structure/</link>
    <description>Recent content in Data Structure on Kevin&#39;s Codex</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 07 Mar 2021 14:35:27 +0900</lastBuildDate><atom:link href="https://klee30810.github.io/tags/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chap1. 자료구조와 알고리즘 이해</title>
      <link>https://klee30810.github.io/compu/data_structure/chap1/</link>
      <pubDate>Sun, 07 Mar 2021 14:34:59 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap1/</guid>
      <description>1. 자료와 자료구조  자료(data)는 현실 세계로부터 단순한 관찰이나 측정을 통해서 수집한 사실(fact)들 또는 값이다. 자료는 가공되지 않은 상태를 의미하고, 정보(information)는 어떤 기준에 의해 정리되고 기록된 것을 의미한다. 자료 구조(Data Structure)는 자료 개체(Data Object)의 집합, 자료 값 사이의 관계 그리고 자료에 적용 가능한 함수 또는 연산 등을 의미한다. 프로그램이란 데이터를 표현하고, 그렇게 표현된 데이터를 처리하는 것이다. 데이터의 표현은 데이터의 저장을 포함하고, 데이터의 저장을 담당하는 것이 자료구조이다.  2. 자료의 구성  비트, 바이트, 단어, 항목, 레코드, 파일, 데이터베이스  3.</description>
    </item>
    
    <item>
      <title>Chap2. 배열</title>
      <link>https://klee30810.github.io/compu/data_structure/chap2/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:01 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap2/</guid>
      <description>1. 배열  배열은 크기와 성격이 같은 자료형을 연속된 기억 장소에 저장한 것이다. 배열 구조는 선형 리스트(linear list) 또는 순서 리스트(ordered list)를 표현하는 가장 일반적인 형태이다. 일반적으로 배열은 배열명(Array name)으로 식별되고, 배열의 요소(원소)는 배열명에 괄호를 붙여 그 안의 첨자(subscript Or index)로 식별한다.
 1차원 배열 (One-dimensional Array Or vector) A는 A(L:U)로 표시할 수 있다.
 이 때, L은 배열 첨자의 하한 값으로 배열의 시작 값을 의미하고, U는 상한 값으로 배열의 마지막 값을 의미한다.</description>
    </item>
    
    <item>
      <title>Chap3. Linked List 1</title>
      <link>https://klee30810.github.io/compu/data_structure/chap3/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:03 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap3/</guid>
      <description>ADT : Abstract Data Type   추상 자료형(ADT) : 구체적인 기능의 완성과 정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것 자료형은 기능의 명세이다! 기능 사용 설명서  ex) int 자료형 : integer를 통해서 가능한 연산(기능)이 나열한 것

 구조체 멤버를 밖에서 접근할 필요 없도록 함수적 기능의 구현 필요 구조체 : Data + 관련 연산  ⇒ 관련 연산이 함께 정의되어야 함!
 C : [구조체&amp;amp;함수 함께 정의: 자료형] + [함수]  배열을 이용한 리스트의 구현  1.</description>
    </item>
    
    <item>
      <title>Chap4. Linked List 2</title>
      <link>https://klee30810.github.io/compu/data_structure/chap4/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:05 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap4/</guid>
      <description>1. 연결 리스트의 개념적인 이해   배열 : 순차적 접근이 index를 통해서 가능 / 크기가 미리 결정 되어야 하고 변경이 불가능 동적할당 : 순차 접근이 불가능 ⇒ 연결 리스트로 관리할 것  1 2 3 4 5  typedef struct _node { int data; // 데이터를 담을 공간 	struct _node * next; // 연결의 도구! } Node;     노드를 연결 다른 노드를 가리키기 위한 포인터 변수 존재  - 예제 LinkedRead.</description>
    </item>
    
    <item>
      <title>Chap5. Linked List 3</title>
      <link>https://klee30810.github.io/compu/data_structure/chap5/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:08 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap5/</guid>
      <description>1. 원형 연결 리스트   단순 연결 리스트의 마지막 노드는 NULL을 가리키지만, 원형 연결 리스트의 마지막 노드는 첫 번째 노드를 가리킨다. 모든 노드가 원의 형태를 이루면서 연결되어 있기 때문에 원형 연결 리스트 에서는 사실상 머리와 꼬리의 구분이 없다.  1. 원형 연결 리스트의 대표적인 장점 
 단순 연결 리스트처럼 머리와 꼬리를 가리키는 포인터 변수를 각각 두지 않아도, 하나의 포인터 변수만 있어도 머리 또는 꼬리에 노드를 간단히 추가할 수 있다.</description>
    </item>
    
    <item>
      <title>Chap6. Stack</title>
      <link>https://klee30810.github.io/compu/data_structure/chap6/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:11 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap6/</guid>
      <description>1. 스택의 이해와 ADT정의   스택은 ‘먼저 들어간 것이 나중에 나오는 자료구조’로써 초코볼이 담겨있는 통에 비유할 수 있다. ⇒ LIFO(Last-in, First-out)  Push : 초코볼 통에 초코볼을 넣는다 Pop : 초코볼 통에서 초코볼을 꺼낸다. (데이터 추출 &amp;amp; 삭제) Peek : 이번에 꺼낼 초코볼의 색이 무엇인지 통 안을 들여다 본다 (데이터 추출만)   ADT 정의 : 배열 혹은 연결 리스트 기반 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void StackInit(Stack * pstack); // 스택의 초기화 진행, 스택 생성 후 제일 먼저 호출되어야 함  int SIsEmpty(Stack * pstack); // 스택인 빈 경우 TRUE, 그렇지 않으면 FALSE  void SPush(Stack * pstack, Data data); // 스택에 데이터를 저장, 매개변수 data로 전달된 값을 저장  Data SPop(Stack * pstack); // 마지막에 저장된 요소를 반환하고 삭제 // 본 함수 호출을 위해 데이터가 하나 이상 존재함이 보장되어야 함 =&amp;gt; SIsEmpty 사용  Data SPeek(Stack * pstack); // 마지막 저장요소를 반환하되 삭제하지 않음 // 본 함수 호출을 위해 데이터가 하나 이상 존재함이 보장되어야 함 =&amp;gt; SIsEmpty 사용    2.</description>
    </item>
    
    <item>
      <title>Chap7. Queue</title>
      <link>https://klee30810.github.io/compu/data_structure/chap7/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:13 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap7/</guid>
      <description>1. 큐의 의해와 ADT 정의  큐는 LIFO(Last-in, First-out) 구조의 자료구조이다. 때문에 먼저 들어간 것이 먼저 나오는, 일종의 줄서기에 비유할 수 있는 자료구조이다 큐에 데이터를 넣는 연산 enqueue &amp;amp; 큐에서 데이터를 꺼내는 연산 dequeue  ADT 정의 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void QueueInit(Queue * pq); // 큐의 초기화 진행, 큐 생성 후 가장 먼저 호출되어야 함  int QIsEmpty(Queue * pq); // 큐가 빈 경우 TRUE(1)  void Enqueue(Queue * pq, Data data); // 큐에 data로 전달된 값을 저장  Data Dequeue(Queue * pq); // 저장 순서가 앞선 데이터를 반환하고 삭제한다.</description>
    </item>
    
    <item>
      <title>Chap8. Tree</title>
      <link>https://klee30810.github.io/compu/data_structure/chap8/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:17 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap8/</guid>
      <description>대부분의 비선형 자료구조는 표현을 목적으로 하며 Tree 구조 또한 그렇다.  1. 트리의 개요  (1) 이진트리  연결리스트 : 노드를 추가하지 않고 데이터를 삽입했다. 트리 : 구조체를 만들고 삽입, 삭제, 추출 등 구조체를 위한 도구가 될 함수를 만들 것이다. 방향보다는 서로간 연결이 더 중요하다. 각자 서로의 주소값을 알고 있으면 연결정보가 있는 것이다. 계층적 관계(Hierarchical Relationship) 을 표현하는 자료구조 데이터 표현을 위한 도구  노드 node: 트리의 구성요소, 실제 data를 담을 수 있는 구조 간선 edge: 노드 간 연결선 루트 노드 root node: 트리 최상위 노드 단말 노드 terminal code : 아래로 다른 노드가 연결되어 있지 않는 노드 내부 노드 internal node : 단말 노드를 제외한 모든 노드 노드간 관계 : 부모 노드, 자식 노드, 형제 노드  서브 트리 : 각 트리는 또다른 서브 트리로 이뤄져 있고 그 주고는 재귀적이다.</description>
    </item>
    
    <item>
      <title>Chap9. Priority Queue &amp; Heap</title>
      <link>https://klee30810.github.io/compu/data_structure/chap9/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:19 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap9/</guid>
      <description>1. 우선순위 큐의 이해   data의 우선순위 결정 → 들어가는 순서와 상관없이 우선순위 근거로 연산 진행 ⇒ 우선순위는 프로그래머가 직접 결정  구현 방법  배열 기반 구현 : 우선순위 기준을 배열에 추가 → data가 많아질 경우 배열이 길어지기 때문에 성능 악화
 연결리스트 기반 구현 : 원하는 값을 찾기 위해 포인터 이동 연산을 ㅁ많이 해야 함 → 성능 악화
 힙을 이용하는 방법
  힙  완전 이진트리의 일종 → 데이터를 넣고 빼기 쉬워서 성능 문제가 없다.</description>
    </item>
    
    <item>
      <title>Chap10. Sort</title>
      <link>https://klee30810.github.io/compu/data_structure/chap10/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:22 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap10/</guid>
      <description>3대 연산 : 삽입, 삭제, 탐색 정렬은 탐색을 이야기 하기 위함 ⇒ 탐색 전에 정렬이 필요!  10.1 단순한 정렬 알고리즘  버블 정렬 (Bubble Sort) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  void BubbleSort(int arr[], int n) { int i, j; int temp; for(i=0; i&amp;lt;n-1; i++) { for(j=0; j&amp;lt;(n-i)-1; j++) { if(arr[j] &amp;gt; arr[j+1]) { // 데이터의 교환  temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } }  1 2 3 4 5 6 7 8 9 10 11 12 13  int main() { int arr[4] = {3,2,4,1}; int i; BubbleSort(arr, sizeof(arr)/sizeof(int)); for(i=0; i&amp;lt;4; i++) printf(&amp;#34;%d &amp;#34;, arr[i]); printf(&amp;#34;\n&amp;#34;); return 0; }    성능평가  비교 횟수 : 두 데이터간의 비교 연산 횟수 이동 횟수 : 위치의 변경을 위한 데이터 이동 횟수   \[(n-1)+.</description>
    </item>
    
    <item>
      <title>Chap11. Search-1</title>
      <link>https://klee30810.github.io/compu/data_structure/chap11/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:23 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap11/</guid>
      <description>&amp;quot;탐색을 잘하기 위한 저장 방법은 무엇인가?&amp;quot; 탐색은 이전에 데이터 정렬이 필수적  1. 탐색의 이해와 보간 탐색   효율적인 탐색을 위한 저장방법, 효율적인 탐색이 가능한 대표적인 자료구조는 &amp;quot;이진트리&amp;quot;이다.  보간 탐색  이진 탐색 : 무조건 중간에 위치한 데이터를 탐색의 위치로 결정 보간 탐색 : 대상에 비례하여 탐색의 위치를 결정 → 단순 비례 가정 후 비슷한 위치 찾기 노력 비례식 구성 → 완전 비례 가정  s : 탐색 대상이 저장된 인덱스 값   \[ A:Q=(high-low):(s-low) \Rightarrow s=\frac{Q}{A}(high-low)+low \\ \Rightarrow s=\frac{x-arr[low]}{arr[high]-arr[low]}(high-low)+low\]</description>
    </item>
    
    <item>
      <title>Chap12. Search-2</title>
      <link>https://klee30810.github.io/compu/data_structure/chap12/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:25 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap12/</guid>
      <description>12.1 균형 잡힌 이진 탐색 트리 : AVL 트리의 이해   트리 → 이진트리 → 이진탐색트리 → 균형잡힌 이진탐색트리 이진 탐색 트리의 연산은 원래 \(O(\log_2n)\)의 시간 복잡도를 가지지만 트리 균형이 맞지 않을수록 \(O(n)\)에 가까운 시간 복잡도를 보인다. ⇒ 약간의 순서 변화로 균형이 잡힌다. AVL 는 균형 인수(Balance Factor)를 기준으로 트리의 균형을 잡기 위한 리밸런싱시기를 결정한다.  균형 인수 = 왼쪽 서브 트리의 높이 - 오른쪽 서브 트리의 높이 균형 인수의 절댓값이 2 이상인 경우 리밸런싱 진행!</description>
    </item>
    
    <item>
      <title>Chap13. Table &amp; Hash*</title>
      <link>https://klee30810.github.io/compu/data_structure/chap13/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:27 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap13/</guid>
      <description>13.1 빠른 탐색을 보이는 해쉬 테이블  테이블 자료구조  데이터가 key와 value로 한 쌍을 이루며, key가 데이터의 저장 및 탐색의 도구가 된다. 테이블 자료구조에서는 원하는 데이터를 단번에 찾을 수 있다. key 역시 의미있는 데이터로 정의하는 것이 좋다.  데이터에 근거하여 생성되어야 하며 중복되면 안된다.  테이블 자료구조의 탐색 연산은 O(1)의 시간복잡도를 보인다. 사전구조 혹은 맵(map)이라고 불린다.  배열 기반 테이블 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  typedef struct _empInfo { int empNum;	// 고유번호 : key  int age;	// 나이 : value } Empinfo; int main() { EmpInfo empInfoArr[1000]; EmpInfo ei; int eNum; printf(&amp;#34;Enter empnum &amp;amp; age: &amp;#34;); scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;(ei.</description>
    </item>
    
  </channel>
</rss>
