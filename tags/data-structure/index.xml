<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure on Kevin&#39;s Codex</title>
    <link>https://klee30810.github.io/tags/data-structure/</link>
    <description>Recent content in Data Structure on Kevin&#39;s Codex</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 07 Mar 2021 14:35:13 +0900</lastBuildDate><atom:link href="https://klee30810.github.io/tags/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chap1. 자료구조와 알고리즘 이해</title>
      <link>https://klee30810.github.io/compu/data_structure/chap1/</link>
      <pubDate>Sun, 07 Mar 2021 14:34:59 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap1/</guid>
      <description>1. 자료와 자료구조  자료(data)는 현실 세계로부터 단순한 관찰이나 측정을 통해서 수집한 사실(fact)들 또는 값이다. 자료는 가공되지 않은 상태를 의미하고, 정보(information)는 어떤 기준에 의해 정리되고 기록된 것을 의미한다. 자료 구조(Data Structure)는 자료 개체(Data Object)의 집합, 자료 값 사이의 관계 그리고 자료에 적용 가능한 함수 또는 연산 등을 의미한다. 프로그램이란 데이터를 표현하고, 그렇게 표현된 데이터를 처리하는 것이다. 데이터의 표현은 데이터의 저장을 포함하고, 데이터의 저장을 담당하는 것이 자료구조이다.  2. 자료의 구성  비트, 바이트, 단어, 항목, 레코드, 파일, 데이터베이스  3.</description>
    </item>
    
    <item>
      <title>Chap2. 배열</title>
      <link>https://klee30810.github.io/compu/data_structure/chap2/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:01 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap2/</guid>
      <description>1. 배열  배열은 크기와 성격이 같은 자료형을 연속된 기억 장소에 저장한 것이다. 배열 구조는 선형 리스트(linear list) 또는 순서 리스트(ordered list)를 표현하는 가장 일반적인 형태이다. 일반적으로 배열은 배열명(Array name)으로 식별되고, 배열의 요소(원소)는 배열명에 괄호를 붙여 그 안의 첨자(subscript Or index)로 식별한다.
 1차원 배열 (One-dimensional Array Or vector) A는 A(L:U)로 표시할 수 있다.
 이 때, L은 배열 첨자의 하한 값으로 배열의 시작 값을 의미하고, U는 상한 값으로 배열의 마지막 값을 의미한다.</description>
    </item>
    
    <item>
      <title>Chap3. Linked List 1</title>
      <link>https://klee30810.github.io/compu/data_structure/chap3/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:03 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap3/</guid>
      <description>ADT : Abstract Data Type   추상 자료형(ADT) : 구체적인 기능의 완성과 정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것 자료형은 기능의 명세이다! 기능 사용 설명서  ex) int 자료형 : integer를 통해서 가능한 연산(기능)이 나열한 것

 구조체 멤버를 밖에서 접근할 필요 없도록 함수적 기능의 구현 필요 구조체 : Data + 관련 연산  ⇒ 관련 연산이 함께 정의되어야 함!
 C : [구조체&amp;amp;함수 함께 정의: 자료형] + [함수]  배열을 이용한 리스트의 구현  1.</description>
    </item>
    
    <item>
      <title>Chap4. Linked List 2</title>
      <link>https://klee30810.github.io/compu/data_structure/chap4/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:05 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap4/</guid>
      <description>1. 연결 리스트의 개념적인 이해   배열 : 순차적 접근이 index를 통해서 가능 / 크기가 미리 결정 되어야 하고 변경이 불가능 동적할당 : 순차 접근이 불가능 ⇒ 연결 리스트로 관리할 것  1 2 3 4 5  typedef struct _node { int data; // 데이터를 담을 공간 	struct _node * next; // 연결의 도구! } Node;     노드를 연결 다른 노드를 가리키기 위한 포인터 변수 존재  - 예제 LinkedRead.</description>
    </item>
    
    <item>
      <title>Chap5. Linked List 3</title>
      <link>https://klee30810.github.io/compu/data_structure/chap5/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:08 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap5/</guid>
      <description>1. 원형 연결 리스트   단순 연결 리스트의 마지막 노드는 NULL을 가리키지만, 원형 연결 리스트의 마지막 노드는 첫 번째 노드를 가리킨다. 모든 노드가 원의 형태를 이루면서 연결되어 있기 때문에 원형 연결 리스트 에서는 사실상 머리와 꼬리의 구분이 없다.  1. 원형 연결 리스트의 대표적인 장점 
 단순 연결 리스트처럼 머리와 꼬리를 가리키는 포인터 변수를 각각 두지 않아도, 하나의 포인터 변수만 있어도 머리 또는 꼬리에 노드를 간단히 추가할 수 있다.</description>
    </item>
    
    <item>
      <title>Chap6. Stack</title>
      <link>https://klee30810.github.io/compu/data_structure/chap6/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:11 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap6/</guid>
      <description>1. 스택의 이해와 ADT정의   스택은 ‘먼저 들어간 것이 나중에 나오는 자료구조’로써 초코볼이 담겨있는 통에 비유할 수 있다. ⇒ LIFO(Last-in, First-out)  Push : 초코볼 통에 초코볼을 넣는다 Pop : 초코볼 통에서 초코볼을 꺼낸다. (데이터 추출 &amp;amp; 삭제) Peek : 이번에 꺼낼 초코볼의 색이 무엇인지 통 안을 들여다 본다 (데이터 추출만)   ADT 정의 : 배열 혹은 연결 리스트 기반 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void StackInit(Stack * pstack); // 스택의 초기화 진행, 스택 생성 후 제일 먼저 호출되어야 함  int SIsEmpty(Stack * pstack); // 스택인 빈 경우 TRUE, 그렇지 않으면 FALSE  void SPush(Stack * pstack, Data data); // 스택에 데이터를 저장, 매개변수 data로 전달된 값을 저장  Data SPop(Stack * pstack); // 마지막에 저장된 요소를 반환하고 삭제 // 본 함수 호출을 위해 데이터가 하나 이상 존재함이 보장되어야 함 =&amp;gt; SIsEmpty 사용  Data SPeek(Stack * pstack); // 마지막 저장요소를 반환하되 삭제하지 않음 // 본 함수 호출을 위해 데이터가 하나 이상 존재함이 보장되어야 함 =&amp;gt; SIsEmpty 사용    2.</description>
    </item>
    
    <item>
      <title>Chap7. Queue</title>
      <link>https://klee30810.github.io/compu/data_structure/chap7/</link>
      <pubDate>Sun, 07 Mar 2021 14:35:13 +0900</pubDate>
      
      <guid>https://klee30810.github.io/compu/data_structure/chap7/</guid>
      <description>1. 큐의 의해와 ADT 정의  큐는 LIFO(Last-in, First-out) 구조의 자료구조이다. 때문에 먼저 들어간 것이 먼저 나오는, 일종의 줄서기에 비유할 수 있는 자료구조이다 큐에 데이터를 넣는 연산 enqueue &amp;amp; 큐에서 데이터를 꺼내는 연산 dequeue  ADT 정의 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void QueueInit(Queue * pq); // 큐의 초기화 진행, 큐 생성 후 가장 먼저 호출되어야 함  int QIsEmpty(Queue * pq); // 큐가 빈 경우 TRUE(1)  void Enqueue(Queue * pq, Data data); // 큐에 data로 전달된 값을 저장  Data Dequeue(Queue * pq); // 저장 순서가 앞선 데이터를 반환하고 삭제한다.</description>
    </item>
    
  </channel>
</rss>
