[
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap1/",
	"title": "Chap1. 코드는 이해하기 쉬워야 한다.",
	"tags": ["programming"],
	"description": "",
	"content": "__01. 무엇이 코드를 ‘더 좋게’ 만드는가? __02. 가독성의 기본 정리  코드는 다른 사람이 그것을 이해하는데 들이는 시간을 최소화하는 방식으로 작성되어야 한다. 누군가 코드를 완전히 이해한다는 것은 그가 코드를 자유롭게 수정하고, 버그를 짚어내고, 수정된 내용이 여러분이 작성한 다른 부분의 코드와 어떻게 상호작용 하는지 알 수 있어야 한다는 뜻이다. 여기서의 누군가는 본인이 될 수도 있다.  __03. 분량이 적으면 항상 더 좋은가?  일반적으로 더 적은 분량의 코드가 보기 좋다. 하지만 그보다는 이해하기 쉬운 코드가 더 좋은 코드이다.  __04. 이해를 위한 시간은 다른 목표와 충돌하는가?  이해하기 쉬운 코드는 코드의 효율성, 잘 구성된 아키텍처, 테스트의 용이성 등의 다른 중요한 조건과 상충되지 않는다.  __05. 어려운 부분\n 이런 고민을 해본적 없었다면 새로운 사고 능력이 필요할 것이다. 하지만 이 목표를 받아들이면 당신은 더 나은 프로그래머가 될 수 있을 것이다.  "
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/",
	"title": "Readable Code Book Review",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Readable Code Readable Code Book Review\n The Art of Readable Code, written by Dustin Boswell et al.  "
},
{
	"uri": "https://klee30810.github.io/indust/semicon/",
	"title": "Semi-conductor Analysis",
	"tags": [],
	"description": "",
	"content": "Analysis 1 Semi-conductor Semi-conductor Industrial Analysis\n"
},
{
	"uri": "https://klee30810.github.io/paper_review/battery/",
	"title": "Battery",
	"tags": [],
	"description": "",
	"content": "Review 1 Battery Paper Review  The Li-Ion Rechargeable Battery: A Perspective, John B. Goodenough  "
},
{
	"uri": "https://klee30810.github.io/paper_review/",
	"title": "Paper Review",
	"tags": [],
	"description": "",
	"content": "Battery   Title Tags Thesis     The Li-Ion Rechargeable Battery: A Perspective overview Li-Ion Battery is hot trend of technology with its cathode, anode, electrolyte, and separation membrane.    Machine Learning \u0026amp; Deep Learning Paper Review | Dog | Woof | | | Cricket | Chirp | | Machine Learning \u0026amp; Deep Learning   Title Tags Thesis     Cat Meow    Dog Woof    Cricket Chirp     "
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap2/",
	"title": "Chap2. 이름에 정보 담기",
	"tags": ["programming"],
	"description": "",
	"content": "★ 이름(식별자)에 정보를 담아내라. 이름을 일종의 설명문으로 생각하라. 좋은 이름은 생각보다 많은 정보를 전달할 수 있다.\n__01. 특정한 단어 고르기  구체적인 단어를 선택하라. 더 '화려한' 단어를 찾아보면 그 변수에 더 적합한 단어를 찾는데 도움이 된다.  ★ 재치 있는 이름보다 명확하고 간결한 이름이 더 좋다.\n\n__02. tmp나 retval 같은 보편적인 이름 피하기 1 2 3 4 5 6  var euclidean_norm = function (v) { var retval = 0.0; for (var i = 0; i \u0026lt; v.length; i += 1) retval += v[i] * v[i]; return Math.sqrt(retval); };   ★ retval이라는 이름은 정보를 제대로 담고 있지 않다. 대신 변수값을 설명하는 이름을 사용하라.\n 하지만 보편적인 이름이 필요한 의미를 더 전달하는 경우도 있다.  ★ tmp라는 이름은 대상이 짧게 임시적으로만 존재하고, 임시적 존재 자체가 변수의 가장 중요한 용도일때에 한해서 사용해야한다.\n1 2 3 4 5  if (right \u0026lt; left) { tmp = right; right = left; left = tmp; } // Acceptable tmp    루프 반복자에 조건문의 이니셜 등을 첨자로 넣으면 더 좋은 이름이 된다.  ★ tmp, it, retval 같은 보편적인 이름을 사용하려면, 꼭 그렇게 해야 하는 이유가 있어야 한다.\n__03. 추상적인 이름보다 구체적인 이름을 선호하라  이름을 지을 때, 추상적인 방식이 아니라 구체적인 방식으로 묘사하라. 예1 : 서버가 어느 TCP/IP 포트를 사용할 수 있는지 검사하는 내부 메소드의 이름은 ServerCanStart()보다 CanListenOnPort()가 더 구체적이다. 예2 : DISALLOW_EVIL_CONSTRUCTOR라는 구글이 사용하던 매크로의 명칭은 사악한(evil)이라는 단어가 너무 강한 표현이고, 매크로가 금지하는(disallowing)대상이 명확하지 않기 때문에 좋은 이름이 아니다. 이 이름은 DISALLOW_COPY_AND_ASSIGN으로 대체되었다. 예3 : 저자들이 사용했던 --run_locally라는 명령행 플래그(command-lind flag) 옵션  1. 새로운 사람이 무엇을 위한 플래그인지 알기 어렵고, 2. 원격으로 실행되는 프로그램에 쓰이기에는 부적절한 이름이었고, 3. 성능 저하의 가능성이 있다는 사실을 담고 있지 않다는 문제점이 있었다. 핵심은 이 이름이 실제 내용보다 주로 사용되는 환경을 나타내는 방식으로 지어졌다는 점이다. 이 이름보다는 --extra_logging이라는 이름이 더 직접적이고 명확하다. 만약 이 플래그가 다른 작업도 수행하며 그 이름이 두 가지 모두를 포괄할 수 있다 하더라도 그럴때는 새로운 역할을 구체적으로 표현하는 새로운 플래그를 만드는 것이 더 좋다.   __04. 추가적인 정보를 이름에 추가하기  이름 안에 들어간 추가 정보는 사용할 때마다 전달된다. 따라서 사용자가 반드시 알아야 하는 정보를 이름에 포함시키는 것이 좋다. 변수가 시간의 양이나 바이트의 수와 같은 측정치를 담고 있다면, 변수명에 단위를 포함시키는게 좋다.  \n 변수의 의미를 제대로 이해하는 것이 중요하다면 그 의미를 드러내는 정보를 변수의 이름에 포함시켜야 한다.  \n__05. 이름은 얼마나 길어야 하는가?  좁은 범위에서는 짧은 이름도 좋다. 하지만 어떤 이름이 넓은 범위에서 사용된다면, 의미를 분명하게 하는 것이 더 중요하다. 팀에 새로 합류한 사람이 이름이 의미하는 바를 이해할 수 있다면 괜찮은 이름이다. 제거해도 정보가 손실 되지 않는 단어는 제거하는 것이 좋다.  __06. 이름 포메팅으로 의미를 전달하라  밑줄(underscores)과 대시(dashes) 그리고 대문자를 잘 이용하면 이름에 더 많은 정보를 담을 수 있다.  1 2 3 4 5 6 7 8 9  static const int kMaxOpenFiles = 100; // NOT MACRO_NAME to be easily distinguished class LogReader { // CamelCase for class names \tpublic: void OpenFile(string local_file); // lower_separated for variable name  private: int offset_; // class member variable ends with an underscore \tDISALLOW_COPY_AND_ASSIGN(LogReader); };     문법적 차이가 드러나게 서로 다른 개체의 이름에 다른 포맷팅 방식을 적용하는 것은 코드를 더 읽기 쉽게 해준다.  __Summary  Use specific words—for example, instead of Get, words like Fetch or Download might be better, depending on the context. Avoid generic names like tmp and retval, unless there’s a specific reason to use them. Use concrete names that describe things in more detail—the name ServerCanStart() is vague compared to CanListenOnPort(). Attach important details to variable names—for example, append ms to a variable whose value is in milliseconds or prepend raw to an unprocessed variable that needs escaping. Use longer names for larger scopes—don’t use cryptic one- or two-letter names for variables that span multiple screens; shorter names are better for variables that span only a few lines. Use capitalization, underscores, and so on in a meaningful way—for example, you can append “_” to class members to distinguish them from local variables.  "
},
{
	"uri": "https://klee30810.github.io/indust/automob/",
	"title": "Automobile Analysis",
	"tags": [],
	"description": "",
	"content": "Analysis 2 Automobile Analysis Automobile Industrial Analysis\n"
},
{
	"uri": "https://klee30810.github.io/paper_review/mldl/",
	"title": "Machine Learning &amp; Deep Learning Paper Review",
	"tags": [],
	"description": "",
	"content": "Review 2 Machine Learning \u0026amp; Deep Learning Machine Learning \u0026amp; Deep Learning Paper Review\n"
},
{
	"uri": "https://klee30810.github.io/mech/",
	"title": "Mechanical Engineering",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Mechanical Engineering Mechanical Engineering Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap3/",
	"title": "Chap3. 오해할 수 없는 이름들",
	"tags": ["programming"],
	"description": "",
	"content": "★ 본인이 지은 이름을 \u0026quot;다른 사람들이 다른 의미로 해석할 수 있을까?\u0026quot;라는 질문을 던져보며 철저하게 확인해야 한다.\n__01. 예: Filter()  filter라는 변수명은 의미가 모호하다. 대상을 '고르는' 기능을 원한다면 select가 '제거하는' 기능을 원한다면 exclude가 더 낫다.  __02. 예: Clip(text, length)  어떤 문단의 내용을 오려내는 함수 Clip(text,length)라면 두 가지 방식으로 이해할 수 있다. 이 함수의 기능은 문단을 처음부터 최대 length만큼 잘라내는 것이므로 truncate(text,max_chars)가 더 좋다. max_length 은 몇몇 애매모호함을 가지고 있다. • A number of bytes • A number of characters • A number of words  __03. 경계를 포함하는 한계값을 다룰 때는 min과 max를 사용하라  CART_TOO_BIG_LIMIT라는 이름은 '그 수까지(up to)'를 의미하는지, '그 수까지(up to including)'를 의미하는지 분명하지 않다  ★ 한계를 설정하는 이름을 가장 명확하게 만드는 방법은 제한 받는 대상의 이름 앞에 max_나 min_을 붙이는 것이다. (max나 min은 그 값을 포함한다는 의미를 갖는다.)\n__04. 경계를 포함하는 범위에는 first와 last를 사용하라 \n 경계의 양 끝점을 포함하는 범위에는 first와 last가 적절하다(inclusive). 이는 시작점과 끝점이라는 정보를 명확하게 전달한다.  __05. 경계를 포함하고/배제하는 범위에는 begin과 end를 사용하라 \n 시작점에서는 경계를 포함하고, 끝점에는 포함하지 않는 범위에는 begin과 end가 관행적으로 가장 적절하다.  __06. 불리언 변수에 이름 붙이기  불리언 변수 혹은 불리언 값을 반환하는 함수에 이름을 붙일 때는 true와 false가 각각 무엇을 의미하는지 명확해야 한다.  ex) read_password → need_password or user_is_authenticated\n 일반적으로 is, has, can, should와 같은 단어를 더하면 불리언 값의 의미가 더 명확해진다. 또한 이름에서는 의미를 부정하는 단어를 피하는 것이 좋다.  __07. 사용자의 기대에 부응하기  프로그래머들이 어떤 이름을 이미 특정한 방식으로 이해해서 실제와 다른 의미로 관행적으로 사용하는 것들이 있다. 이런 경우에는 그것을 따르는 것이 좋다. get*() : get으로 시작되는 이름의 메소드는 '가벼운 접근자(lightweight accessos'로서 단순히 내부 멤버를 반환한다고 관행적으로 생각한다. list:size() : list.size()는 C++표준 라이브러리에 있던 메소드인데 이는 O(n)연산을 했다. 하지만 프로그래머들은 size() 메소드가 일정한 시간을 소비한다고 관행적으로 생각한다. c++에 존재하는 다른 모든 size()메소드는 일정한 시간을 소비하기 때문이다. 이럴때는 메소드명을 size()가 아니라 countSize()나 countElements()라 했다면 오해를 피할 수 있었을 것이다. 다행히도 최근에 C++ 표준 라이브러리에서 \u0026quot;size()는 O(1)이어야 한다.\u0026quot;는 규칙을 정했다.  __08. 예: 이름을 짓기 위해서 복수의 후보를 평가하기  좋은 이름을 정하기 위해서는 여러개의 후보를 놓고 이것이 명확한 의미를 전달하는지를 따져보는 습관을 가질 필요가 있다.  __요약  The best names are ones that can’t be misconstrued—the person reading your code will understand it the way you meant it, and no other way. Unfortunately, a lot of English words are ambiguous when it comes to programming, such as filter, length, and limit. Before you decide on a name, play devil’s advocate and imagine how your name might be misunderstood. The best names are resistant to misinterpretation. When it comes to defining an upper or lower limit for a value, max_ and min_ are good prefixes to use. For inclusive ranges, first and last are good. For inclusive/exclusive ranges, begin and end are best because they’re the most idiomatic. When naming a boolean, use words like is and has to make it clear that it’s a boolean. Avoid negated terms (e.g., disable_ssl). Beware of users’ expectations about certain words. For example, users may expect get() or size() to be lightweight methods.  "
},
{
	"uri": "https://klee30810.github.io/elec/",
	"title": "Electrical &amp; Electronic Studies",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Electrical \u0026amp; Electronic Engineering Electrical \u0026amp; Electronic Engineering Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap4/",
	"title": "Chap4. 미학",
	"tags": ["programming"],
	"description": "",
	"content": "-좋은 소스코드는 '눈을 편하게' 해야 한다. 이 장에서는 다음과 같은 세 가지 원리가 사용된다.\n1. 코드를 읽는 사람이 이미 친숙한, 일관성 있는 레이아웃을 사용하라.\n2. 비슷한 코드는 서로 비슷해 보이게 만들어라.\n3. 서로 연관된 코드는 하나의 블록으로 묶어라.\n※ 여기서 말하는 미학은 가독성 만을 위한 것으로 새롭게 설계하는 리팩토링은 서로 독립된 아이디어에 해당한다. 두 가지 모두를 추구하는게 이상적이다.\n__01. 미학이 무슨 상관인가?  미학적으로 보기 좋은 코드가 사용하기 더 편리하다. 우리는 대부분의 시간을 코드를 그저 바라보는 데 쓴다는 것을 명심하라.  __02. 일관성과 간결성을 위해서 줄 바꿈을 재정렬하기 1 2 3 4 5 6 7 8 9 10  public class PerformanceTester { // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)  // [Kbps] [ms] [ms] [percent] \tpublic static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(500, 80, 200, 1); public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(45000, 10, 0, 0); public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(100, 400, 250, 5); }    줄이 길어져 줄바꿈을 해야한다면 다른 비슷한 코드도 같은 방식으로 줄바꿈을 하는게 좋다. (비슷한 코드는 서로 비슷해 보이게 만들어라!)  __03. 메소드를 활용하여 불규칙성을 정리하라 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // BAD EXAMPLE // Turn a partial_name like \u0026#34;Doug Adams\u0026#34; into \u0026#34;Mr. Douglas Adams\u0026#34;. // If not possible, \u0026#39;error\u0026#39; is filled with an explanation. string ExpandFullName(DatabaseConnection dc, string partial_name, string* error); DatabaseConnection database_connection; string error; assert(ExpandFullName(database_connection, \u0026#34;Doug Adams\u0026#34;, \u0026amp;error) == \u0026#34;Mr. Douglas Adams\u0026#34;); assert(error == \u0026#34;\u0026#34;); assert(ExpandFullName(database_connection, \u0026#34; Jake Brown \u0026#34;, \u0026amp;error) == \u0026#34;Mr. Jacob Brown III\u0026#34;); assert(error == \u0026#34;\u0026#34;); assert(ExpandFullName(database_connection, \u0026#34;No Such Guy\u0026#34;, \u0026amp;error) == \u0026#34;\u0026#34;); assert(error == \u0026#34;no match found\u0026#34;); assert(ExpandFullName(database_connection, \u0026#34;John\u0026#34;, \u0026amp;error) == \u0026#34;\u0026#34;); assert(error == \u0026#34;more than one result\u0026#34;);  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // GOOD EXAMPLE CheckFullName(\u0026#34;Doug Adams\u0026#34;, \u0026#34;Mr. Douglas Adams\u0026#34;, \u0026#34;\u0026#34;); CheckFullName(\u0026#34; Jake Brown \u0026#34;, \u0026#34;Mr. Jake Brown III\u0026#34;, \u0026#34;\u0026#34;); CheckFullName(\u0026#34;No Such Guy\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;no match found\u0026#34;); CheckFullName(\u0026#34;John\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;more than one result\u0026#34;); void CheckFullName(string partial_name, string expected_full_name, string expected_error) { // database_connection is now a class member \tstring error; string full_name = ExpandFullName(database_connection, partial_name, \u0026amp;error); assert(error == expected_error); assert(full_name == expected_full_name); }    같은 내용의 코드가 반복되어야 한다면 이를 새로운 메소드로 작성하라. 이는 미학적 개선(가독성 향상)을 위한 한 일이지만 다음과 같은 장점들도 있다.   중복된 코드를 없애서 코드를 더 간결하게 한다.\n 이름이나 에러 문자열 같은 테스트의 중요 부분들이 한 눈에 보이게 모아졌다.\n 새로운 테스트 추가가 훨씬 쉬워졌다.\n  __04. 도움이 된다면 코드의 열을 맞춰라 1 2 3 4 5 6 7 8 9  commands[] = { ... { \u0026#34;timeout\u0026#34;, NULL, cmd_spec_timeout }, { \u0026#34;timestamping\u0026#34;, \u0026amp;opt.timestamping, cmd_boolean }, { \u0026#34;tries\u0026#34;, \u0026amp;opt.ntry, cmd_number_inf }, { \u0026#34;useproxy\u0026#34;, \u0026amp;opt.use_proxy, cmd_boolean }, { \u0026#34;useragent\u0026#34;, NULL, cmd_spec_useragent }, ... };    비슷한 코드를 행과 열을 맞춰서 정렬하면 파라메터 값들을 더 쉽게 확인할 수 있고, 탈자로 인한 버그도 손쉽게 찾을 수 있다.  __05. 의미 있는 순서를 선택하고 일관성 있게 사용하라  순서가 중요하지 않은 코드의 경우에는 임의의 순서가 아니라 의미있는 순서로 나열하는 것이 좋다.  ex1 ) 변수의 순서를 HTML 폼에 있는 input 필드의 순서대로 나열하기.\nex2 ) '가장 중요한 것'에서 시작해서 '덜 중요한 것' 순으로 나열하기.\nex3 ) 알파벳 순서대로 나열하기\n__06. 선언문을 블록으로 구성하라 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class FrontendServer { public: FrontendServer(); ~FrontendServer(); // Handlers \tvoid ViewProfile(HttpRequest* request); void SaveProfile(HttpRequest* request); void FindFriends(HttpRequest* request); // Request/Reply Utilities \tstring ExtractQueryParam(HttpRequest* request, string param); void ReplyOK(HttpRequest* request, string html); void ReplyNotFound(HttpRequest* request, string error); // Database Helpers \tvoid OpenDatabase(string location, string user); void CloseDatabase(string location); };     코드들을 논리적 영역에 따라 그룹화하고 주석을 붙여라.  __07. 코드를 ‘문단’으로 쪼개라 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def suggest_new_friends(user, email_password): # Get the user\u0026#39;s friends\u0026#39; email addresses. friends = user.friends() friend_emails = set(f.email for f in friends) # Import all email addresses from this user\u0026#39;s email account. contacts = import_contacts(user.email, email_password) contact_emails = set(c.email for c in contacts) # Find matching users that they aren\u0026#39;t already friends with. non_friend_emails = contact_emails - friend_emails suggested_friends = User.objects.select(email__in=non_friend_emails) # Display these lists on the page. display[\u0026#39;user\u0026#39;] = user display[\u0026#39;friends\u0026#39;] = friends display[\u0026#39;suggested_friends\u0026#39;] = suggested_friends return render(\u0026#34;suggested_friends.html\u0026#34;, display)    코드들이 하는 일을 논리적으로 설명하기 좋게 문단을 나눠라.  __08. 개인적인 스타일 대 일관성 ★ 일관성 있는 스타일은 '올바른' 스타일보다 더 중요하다.\n__요약  If multiple blocks of code are doing similar things, try to give them the same silhouette. Aligning parts of the code into “columns” can make code easy to skim through. If code mentions A, B, and C in one place, don’t say B, C, and A in another. Pick a meaningful order and stick with it. Use empty lines to break apart large blocks into logical “paragraphs.”  "
},
{
	"uri": "https://klee30810.github.io/compu/",
	"title": "Compu",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Computer Science Computer Science Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap5/",
	"title": "Chap5. 주석에 담아야 하는 대상",
	"tags": ["programming"],
	"description": "",
	"content": "★ 주석의 목적은 코드를 읽는 사람이 코드를 작성한 사람만큼 코드를 잘 이해하게 돕는 데 있다.\n__01. 설명하지 말아야 하는 것 ★ 코드에서 빠르게 유추할 수 있는 내용은 주석으로 달지 말라.\n 설명 자체를 위한 설명을 달지 말라. 주석을 달아야하겠다면 파악하기 어려운 세부사항을 적는것이 좋다.\n 나쁜 이름에 주석을 달지 마라. 대신 이름을 고쳐라. 좋은 코드 \u0026gt; 나쁜 코드 + 좋은 주석\n  __02. 생각을 기록하라  코드를 짜면서 의도한 바나 깨달은 바를 주석으로 기록하라. 상수가 무엇을 하는지, 그것이 왜 특정한 값을 갖게 되었는지에 대한 내용을 기록해둬라. 코드에 있는 결함을 설명하라. 코드에 부족한 점이 있는건 당연하고, 당장 그것을 고칠 시간이 없을때도 많다. 코드의 어떠한 내용을 훗날 수정할 것이라는 생각이 들면 이를 주석으로 작성하는 걸 당연하게 받아들여라. 코드에 개선해야 할 점이 있다고 생각된다면 이를 주석으로 기록하라. 다음은 이를 위해 자주 쓰이는 표시들이다.  \n__03. 코드를 읽는 사람의 입장이 되어라  코드를 처음으로 읽는 외부인의 입장이 되어보라. 나올 것 같은 질문 예측하기 : 누군가가 코드를 읽었을 때 할법한 질문의 답변을 주석으로 달아라. 사람들이 쉽게 빠질 것 같은 함정을 경고하라 : 코드를 쓰다가 생길수 있는 문제점을 미리 예측해서 주석으로 달아라. '큰 그림'에 대한 주석 : 특정 코드가 상위 수준의 문제와 어떻게 연결되어 있는지를 주석으로 달아라. 이는 함수 내부에서 코드의 목적을 설명하는 식으로도 적용될 수 있다. 사람들이 코드를 쉽게 읽을 수 있게 도와주는 내용이라면 그것이 무엇이든지 적어두는 것이 좋다.  __04. 마지막 고찰 - 글 쓰는 두려움을 떨쳐내라  그냥 떠오르는 생각이라도 써있는 것이 아무것도 안 써있는 것보다는 좋다. 떠오른 생각을 적은 주석의 표현들을 좀 더 구체적인 표현으로 바꾸다보면 사람들이 읽기 편한 주석을 작성할 수 있다.  __요약  What not to comment:\n Facts that can be quickly derived from the code itself. “Crutch comments” that make up for bad code (such as a bad function name)—fix the code instead.  Thoughts you should be recording include:\n Insights about why code is one way and not another (“director commentary”). Flaws in your code, by using markers like TODO: or XXX:.\n The “story” for how a constant got its value.  Put yourself in the reader’s shoes:\n Anticipate which parts of your code will make readers say “Huh?” and comment those. Document any surprising behavior an average reader wouldn’t expect. Use “big picture” comments at the file/class level to explain how all the pieces fit together. Summarize blocks of code with comments so that the reader doesn’t get lost in the details.   "
},
{
	"uri": "https://klee30810.github.io/mldl/",
	"title": "Machine Learning &amp; Deep Learning",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Machine Learning \u0026amp; Deep Learning Machine Learning \u0026amp; Deep Learning Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap6/",
	"title": "Chap6. 명확하고 간결한 주석 달기",
	"tags": ["programming"],
	"description": "",
	"content": " 주석은 높은 '정보 대 공간' 비율을 맞춰야 한다.  __01. 주석을 간결하게 하라 1 2 3 4 5 6 7 8  // The int is the CategoryType. // The first float in the inner pair is the \u0026#39;score\u0026#39;, // the second is the \u0026#39;weight\u0026#39;. typedef hash_map\u0026lt;int, pair\u0026lt;float, float\u0026gt; \u0026gt; ScoreMap; /* CONCISE ONE!!! */ // CategoryType -\u0026gt; (score, weight) typedef hash_map\u0026lt;int, pair\u0026lt;float, float\u0026gt; \u0026gt; ScoreMap;     짧게 줄여도 정보를 충분히 전달할 수 있다면 주석을 짧게 줄여라.  __02. 모호한 대명사는 피하라  모호한 대명사는 원래 명사로 고치거나, 의미가 명확해지도록 문장을 고쳐라.  __03. 엉터리 문장을 다듬어라  주석을 명확하게 하는 작업과 간결하게 하는 작업은 대부분 한꺼번에 이루어진다.   __04. 함수의 동작을 명확하게 설명하라 1 2  // Count how many newline bytes (\u0026#39;\\n\u0026#39;) are in the file. int CountLines(string filename) { ... }     애매한 단어를 사용하지 말고 구현한 방식을 명확하게 설명하는 것이 좋다.  __05. 구체적인 용법을 설명해주는 입/출력 예를 사용하라 1 2 3  // ... // Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1 int Partition(vector\u0026lt;int\u0026gt;* v, int pivot);     주석을 작성하는 데 신중하게 선택된 입/출력 예는 천 마디 말보다 위력적이다. 모든 동작을 표현할 수 있는 입/출력 예를 주석으로 사용하라.  __06. 코드의 의도를 명시하라  이러한 주석은 코드가 의도와 다르게 작동하는지 확인하기 좋다.  __07. 이름을 가진 함수 파라미터 주석  뜻이 잘 드러나는 이름을 지을 수 없거나 값을 전달할 때 그 값의 의미를 알기가 힘들다면 값의 앞에 주석을 달아라.  __08. 정보 축약형 단어를 사용하라 1 2 3 4 5 6 7 8  As another example, a comment such as: // Remove excess whitespace from the street address, and do lots of other cleanup // like turn \u0026#34;Avenue\u0026#34; into \u0026#34;Ave.\u0026#34; This way, if there are two different street addresses // that are typed in slightly differently, they will have the same cleaned-up version and // we can detect that these are equal.  could instead be: // Canonicalize the street address (remove extra spaces, \u0026#34;Avenue\u0026#34; -\u0026gt; \u0026#34;Ave.\u0026#34;, etc.)     지속적으로 반복되는 문제에 대해서는 이를 표현하기 위한 관용적 표현이 만들어져 있는 경우가 많다. 이를 찾아보고 활용하라.  ex) '경험적인(heuristic)', '주먹구구식(brute_force)', '순진한 해법(native solution)' 등\n__요약  Avoid pronouns like “it” and “this” when they can refer to multiple things. Describe a function’s behavior with as much precision as is practical. Illustrate your comments with carefully chosen input/output examples. State the high-level intent of your code, rather than the obvious details. Use inline comments (e.g., Function(/* arg = */ ... ) ) to explain mysterious function arguments. Keep your comments brief by using words that pack a lot of meaning.  "
},
{
	"uri": "https://klee30810.github.io/battery/",
	"title": "Battery",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Battery Battery Studies in diverse field\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap7/",
	"title": "Chap7. 읽기 쉽게 흐름제어 만들기",
	"tags": ["programming"],
	"description": "",
	"content": " 제어문은 사실 코드를 읽기 어렵게 만든다.  ★ 흐름을 제어하는 조건과 루프 그리고 여타 요소를 최대한 '자연스럽게' 만들도록 노력하라.코드를 읽다가 다시 되돌아가서 코드를 읽지 않아도 되게끔 만들어야 한다.\n__01. 조건문에서 인수의 순서  왼쪽에 '질문을 받는' 유동적인 값을 쓰고, 오른쪽에 비교대상으로 사용되는 고정적인 값을 써라.  __02. if/else 블록의 순서  조건은 부정문이 아닌 긍정문으로 쓰려고하라. 간단한 것을 먼저 처리하라. 이러면 한 화면으로 두개의 구문을 볼 수 있을 가능성이 높아진다. 더 흥미롭고, 확실한 것을 먼저 다루어라. 위의 세가지 규칙이 서로 충돌을 일으킬 수도 있다. 중요한 것은 자신이 작성한 if/else문이 이상한 순서로 작성되었는지 확인하라는 것이다.  __03. (삼항 연산자로 알려진)?:를 이용하는 조건문 표현 ★ 줄 수를 최소하는 일보다 다른 사람이 코드를 읽고 이해하는데 걸리는 시간을 최소화하는 일이 더 중요하다.\n★ 기본적으로 if/else를 이용하라. ?:를 이용하는 삼항 연산은 매우 간단할 때만 사용해야 한다.\n__04. do/while 루프를 피하라  do/while루프는 코드를 두번 읽도록 만든다. 반면에 while 루프는 반복 조건을 먼저 확인할 수 있으므로 읽기 좋다.\n 하지만 do/while을 제거하려고 중복된 코드를 사용하진 말라. 그렇게 하지 않아도 대부분의 do/while루프를 while루프로 변경할 수 있다.\n 특히 do/while루프 안에서 continue를 사용하면 혼란을 초래하므로 피하는 것이 좋다.\n(다만 이 조언이 do/while루프를 절대 쓰지 말라는 뜻은 아니다.)\n  ★ \u0026quot;내 경험으로 에러와 혼동의 원인은 do문에 있다. 그래서 나는 조건이 '눈에 띄는 곳에 미리' 나타나도록 만드는 것을 선호한다.\n 결과적으로 나는 do문을 피하는 경향이 있다.\u0026quot; - C++의 창시자 \u0026quot;반얀 스토라우스트럽\u0026quot;  __05. 함수 중간에서 반환하기  반환 포인트를 하나만 두려는건 함수의 끝부분에서 실행되는 클린업(cleanup)코드의 호출을 보장하려는 의도이다. 하지만 현대의 언어들은 클린업 코드를 실행시키는 더 정교한 방법을 제공하고 있다. 그러므로 이제는 함수 중간에서 반환하는 것은 완전히 허용되어야 한다.  __06. 악명 높은 goto  goto를 쓰면 코드가 쉽게 엉망진창이 될 가능성이 높으므로 피하는 것이 좋다. 하지만 클린업 코드를 실행시키기 위해서 함수의 맨 밑으로 단 하나의 exit 포인트만 두는 방식이라면 goto의 괜찮은 사용법이라 할 수 있다.  (어지럽게 중첩된 코드에서 한번에 빠져나오기 위한 용도로도 goto는 유용하다. 그런 코드 자체를 지양해야겠지만 말이다.)\n__07. 중첩을 최소화하기  코드가 중첩된다는 것은 읽는 사람에게는 정신적 스택에 추가적인 조건이 입력된다는 뜻이다. 중첩이 추가되는 상황은 주로 코드를 수정하는 과정에서 새로운 코드를 추가할 때이다.  ★ 코드를 수정해야 하는 상황이 오면 코드를 새로운 관점에서 혹은 코드 전체를 보고 어떻게 수정하면 좋을지 생각해보라.\n 함수 중간에서 반환하여 중첩을 제거하라 (if/return) 밖으로 빠져나가지 않고 루프 중간에서 반환해야 한다면 continue를 사용하면 된다. (if/continue)\n 일반적으로 continue문은 goto처럼 논리의 흐름을 건너뛰게 하므로 읽는 이를 혼란스럽게 만들 수 있다. 하지만 루프에 대한 각각의 반복이 독립적이라면 continue문이 단지 이번 반복을 건너뛰어라라는 의미임을 쉽게 확인할 수 있다.  우리는 자신의 프로그램에 존재하는 '흐름'을 상위 수준에서 조망해볼 필요가 있다.\n 궁극적인 목표는 프로그램의 전체 실행 경로를 쉽게 따라갈 수 있게 만드는 것이기 때문이다. 다음은 흐름을 따라가기 어렵게 만드는 구조들이다. 이러한 구조들은 가능하면 사용을 지양하는 것이 좋다.\n  __08. 실행 흐름을 따라올 수 있는가? \n__요약  When writing a comparison (while (bytes_expected \u0026gt; bytes_received)), it’s better to put the changing value on the left and the more stable value on the right (while (bytes_received \u0026lt; bytes_expected)). You can also reorder the blocks of an if/else statement. Generally, try to handle the positive/easier/interesting case first. Sometimes these criteria conflict, but when they don’t, it’s a good rule of thumb to follow. Certain programming constructs, like the ternary operator (: ?), the do/while loop, and goto often result in unreadable code. It’s usually best not to use them, as clearer alternatives almost always exist. Nested code blocks require more concentration to follow along. Each new nesting requires more context to be “pushed onto the stack” of the reader. Instead, opt for more “linear” code to avoid deep nesting. Returning early can remove nesting and clean up code in general. “Guard statements” (handling simple cases at the top of the function) are especially useful.  "
},
{
	"uri": "https://klee30810.github.io/finance/",
	"title": "Finance",
	"tags": [],
	"description": "",
	"content": "Chapter 7 Finance Finance Studies.\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap8/",
	"title": "Chap8. 거대한 표현을 잘게 쪼개기",
	"tags": ["programming"],
	"description": "",
	"content": "★ 거대한 표현을 더 소화하기 쉬운 여러 조각으로 나눈다.\n__01. 설명 변수  거대한 표현을 쪼개는 가장 쉬운 방법은 작은 하위 표현을 담을 '추가 변수(extra variable)'을 만드는 것이다.  1 2 3 4 5 6 7  // Here is an example: if line.split(\u0026#39;:\u0026#39;)[0].strip() == \u0026#34;root\u0026#34;: ... //Here is the same code, now with an explaining variable: username = line.split(\u0026#39;:\u0026#39;)[0].strip() if username == \u0026#34;root\u0026#34;: ...     추가 변수는 하위 표현의 의미를 설명하므로 '설명 변수(explaning variable)'라고도 한다.  __02. 요약 변수 1 2 3 4 5 6 7 8  final boolean user_owns_document = (request.user.id == document.owner_id); if (user_owns_document) { // user can edit this document... } ... if (!user_owns_document) { // document is read-only... }     커다란 코드의 덩어리를 짧은 이름으로 대체하여 더 쉽게 관리하고 파악하는 목적으로 만드는 변수를 '요약 변수(summary variable)'라고 한다. 요약 변수를 통해 읽는 사람이 코드의 주된 개념을 더 쉽게 파악할 수 있게 도와줄 수 있다.  __03. 드모르간의 법칙 사용하기  not (a or b or c) \u0026lt;=\u0026gt; (not a) and (not b) and (not c) not (a and b and c) \u0026lt;=\u0026gt; (not a) or (not b) or (not c)  __04. 쇼트 서킷 논리 오용하기  쇼트 서킷 논리를 복잡한 연산에 사용하면 가독성을 해칠 수 있다.  ★ '영리하게' 작성된 코드에 유의하라. 나중에 다른 사람이 읽으면 그런 코드가 종종 혼란을 초래한다.\n 파이썬, JS, 루비 같은 언어는 or 연산자가 인수 중 하나를 반환한다.  따라서 x = a || b|| c 라는 코드는 a,b,c 세 값 중에서 첫 번째 '참'값을 반환하는데 사용할 수 있다.\n__05. 예: 복잡한 논리와 씨름하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14  struct Range { int begin; int end; // For example, [0,5) overlaps with [3,8) \tbool OverlapsWith(Range other); }; bool Range::OverlapsWith(Range other) { // Check if \u0026#39;begin\u0026#39; or \u0026#39;end\u0026#39; falls inside \u0026#39;other\u0026#39;. \treturn (begin \u0026gt;= other.begin \u0026amp;\u0026amp; begin \u0026lt; other.end) || (end \u0026gt; other.begin \u0026amp;\u0026amp; end \u0026lt;= other.end) || (begin \u0026lt;= other.begin \u0026amp;\u0026amp; end \u0026gt;= other.end); }     One technique is to see if you can solve the problem the “opposite” way. Depending on the situation you’re in, this could mean iterating through arrays in reverse or filling in some data structure backward rather than forward.  1 2 3 4 5 6 7 8 9 10 11  /* 1. The other range ends before this one begins. 2. The other range begins after this one ends. */ // We can turn this into code quite easily:  bool Range::OverlapsWith(Range other) { if (other.end \u0026lt;= begin) return false; // They end before we begin if (other.begin \u0026gt;= end) return false; // They begin after we end return true; // Only possibility left: they overlap }    __06. 거대한 구문 나누기 1 2 3 4 5 6 7 8 9 10 11 12 13  // BAD var update_highlight = function (message_num) { if ($(\u0026#34;#vote_value\u0026#34; + message_num).html() === \u0026#34;Up\u0026#34;) { $(\u0026#34;#thumbs_up\u0026#34; + message_num).addClass(\u0026#34;highlighted\u0026#34;); $(\u0026#34;#thumbs_down\u0026#34; + message_num).removeClass(\u0026#34;highlighted\u0026#34;); } else if ($(\u0026#34;#vote_value\u0026#34; + message_num).html() === \u0026#34;Down\u0026#34;) { $(\u0026#34;#thumbs_up\u0026#34; + message_num).removeClass(\u0026#34;highlighted\u0026#34;); $(\u0026#34;#thumbs_down\u0026#34; + message_num).addClass(\u0026#34;highlighted\u0026#34;); } else { $(\u0026#34;#thumbs_up\u0026#34; + message_num).removeClass(\u0026#34;highighted\u0026#34;); $(\u0026#34;#thumbs_down\u0026#34; + message_num).removeClass(\u0026#34;highlighted\u0026#34;); } };     거대한 구문에서도 동일한 부분을 요약 변수나 함수로 추출해서 구문의 앞부분에 놓아둘 수 있다. 이는 DRY-Don't Repeat Yourself의 원리이기도 하다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // GOOD var update_highlight = function (message_num) { var thumbs_up = $(\u0026#34;#thumbs_up\u0026#34; + message_num); var thumbs_down = $(\u0026#34;#thumbs_down\u0026#34; + message_num); var vote_value = $(\u0026#34;#vote_value\u0026#34; + message_num).html(); var hi = \u0026#34;highlighted\u0026#34;; if (vote_value === \u0026#34;Up\u0026#34;) { thumbs_up.addClass(hi); thumbs_down.removeClass(hi); } else if (vote_value === \u0026#34;Down\u0026#34;) { thumbs_up.removeClass(hi); thumbs_down.addClass(hi); } else { thumbs_up.removeClass(hi); thumbs_down.removeClass(hi); } };     이렇게 하면 다음과 같은 장점이 있다.   타이핑 실수를 피할 수 있다.\n 코드를 한눈에 훑어보기 좋도록 코드의 길이를 조금이라도 줄여준다.\n 클래스명을 변경해야 할 때 한 곳만 바꾸면 된다.\n  __07. 표현을 단순화하는 다른 창의적인 방법들 1 2 3 4 5 6 7 8  void AddStats(const Stats\u0026amp; add_from, Stats* add_to) { add_to-\u0026gt;set_total_memory(add_from.total_memory() + add_to-\u0026gt;total_memory()); add_to-\u0026gt;set_free_memory(add_from.free_memory() + add_to-\u0026gt;free_memory()); add_to-\u0026gt;set_swap_memory(add_from.swap_memory() + add_to-\u0026gt;swap_memory()); add_to-\u0026gt;set_status_string(add_from.status_string() + add_to-\u0026gt;status_string()); add_to-\u0026gt;set_num_processes(add_from.num_processes() + add_to-\u0026gt;num_processes()); ... }     C++에서는 비슷한 표현을 매크로 함수로 정의해서 줄일수도 있다.  1 2 3 4 5 6 7 8 9 10  void AddStats(const Stats\u0026amp; add_from, Stats* add_to) { #define ADD_FIELD(field) add_to-\u0026gt;set_##field(add_from.field() + add_to-\u0026gt;field()) \tADD_FIELD(total_memory); ADD_FIELD(free_memory); ADD_FIELD(swap_memory); ADD_FIELD(status_string); ADD_FIELD(num_processes); ... #undef ADD_FIELD }     매크로의 사용은 권장할 것이 아니지만 적절히 사용하면 코드 가독성을 높일 수 있다.  __요약  One simple technique is to introduce “explaining variables” that capture the value of some large subexpression. This approach has three benefits: • It breaks down a giant expression into pieces. • It documents the code by describing the subexpression with a succinct name. • It helps the reader identify the main “concepts” in the code. Another technique is to manipulate your logic using De Morgan’s laws—this technique can sometimes rewrite a boolean expression in a cleaner way (e.g., if (!(a \u0026amp;\u0026amp; !b)) turns into if (!a || b)). We showed an example where a complex logical condition was broken down into tiny statements like “if (a \u0026lt; b) ...”. In fact, all of the improved-code examples in this chapter had if statements with no more than two values inside them. This setup is ideal. It may not always seem possible to do this—sometimes it requires “negating” the problem or considering the opposite of your goal.  "
},
{
	"uri": "https://klee30810.github.io/math/",
	"title": "Mathematics",
	"tags": [],
	"description": "",
	"content": "Chapter 8 Mathematics Mathematics Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap9/",
	"title": "Chap9. 변수와 가독성",
	"tags": ["programming"],
	"description": "",
	"content": " 변수를 잘못 사용하면 다음과 같은 문제가 있다.   변수의 수가 많을수록 기억하고 다루기 더 어려워진다.\n 변수의 범위가 넓어질수록 기억하고 다루는 시간이 더 길어진다.\n 변수값이 자주 바뀔수록 현재값을 기억하고 다루기가 더 어려워진다.\n  __01. 변수 제거하기  가독성에 도움되지 않는 변수는 제거하는 것이 좋다.\n It isn’t breaking down a complex expression. It doesn’t add clarification—the expression datetime.datetime.now() is clear enough. It’s used only once, so it doesn’t compress any redundant code.  불필요한 임시 변수 : 복잡한 표현을 나누는 것도 아니고, 명확성에 도움이 되는 것도 아니고, 중복된 코드를 압축하지도 않는 임시 변수.\n 중간 결과 삭제하기\n  1 2 3 4 5 6 7 8 9 10 11 12 13  // BAD var remove_one = function (array, value_to_remove) { var index_to_remove = null; for (var i = 0; i \u0026lt; array.length; i += 1) { if (array[i] === value_to_remove) { index_to_remove = i; break; } } if (index_to_remove !== null) { array.splice(index_to_remove, 1); } };  1 2 3 4 5 6 7 8 9 10  var remove_one = function (array, value_to_remove) { for (var i = 0; i \u0026lt; array.length; i += 1) { if (array[i] === value_to_remove) { array.splice(i, 1); return; } } }; // it’s a good strategy to complete the task as quickly as possible.    흐름 제어 변수 제거하기 : 순수하게 프로그램의 실행 방향을 설정하는데 사용하는 변수는 구조를 변경하는 것으로 제거할 수 있다.  __02. 변수의 범위를 좁혀라 ★ 모든 변수에 대해서 변수가 적용되는 범위를 최대한 좁게 만들어라.  변수의 범위를 좁히면 코드를 읽는 사람이 한꺼번에 생각해야 하는 변수의 수를 줄여주기 때문이다. 클래스 멤버 변수도 클래스 안의 전역 변수라 할 수 있다. 이런 변수도 지역변수로 강등시키는 것이 좋다.  1 2 3 4 5 6 7 8 9 10 11 12  // For this case, it may make sense to “demote” str_ to be a local variable: class LargeClass { void Method1() { string str = ...; Method2(str); } void Method2(string str) { // Uses str \t} // Now other methods can\u0026#39;t see str. };     메소드를 정적 static으로 만들어 클래스 멤버 접근을 제한하면 읽는 사람에게 이 메소드가 변수들로부터 독립적이라는 사실을 알려줄 수 있다. 커다란 클래스를 독립적인 작은 클래스로 나눌 수 있다면 나누는 것이 좋다. - 변수는 사용하기 직전에 선언해서 사용 범위가 끝나면 해제되게 하는 것이 좋다.\n C++에서는 조건문 안에서 변수를 선언할 수 있다. 이렇게 하면 그 변수는 조건문 안에서만 사용되는 것이 명확해진다.\n 자바스크립트에서는 클로저(closure) 내부에 집어넣어 그 함수에서만 사용되게 할 수 있다.\n 자바스크립트에서 변수를 정의할 때 var를 생략하면 해당 변수는 전역 변수가 된다.\n 파이썬과 자바스크립트에는 중첩된 범위가 없으므로 '가장 인접한 공통 조상(closer common ancestor)'에 정의하여 코드의 가독성을 높일 수 있다.\n  __03. 값을 한 번만 할당하는 변수를 선호하라  값이 고정된 변수는 읽는 사람에게 별다른 추가적인 생각을 요구하지 않는다. 그러므로 C++에서는 const 사용을, 자바에서는 final 사용을 권장한다.  ★ 변수값이 달라지는 곳이 많을수록 현재값을 추측하기 더 어려워진다. 그러므로 최대한 적은 횟수로 변하도록 설계하라.\n__04. 마지막 예  아래와 같은 HTML이 있고,  1 2 3 4  \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input1\u0026#34; value=\u0026#34;Dustin\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input2\u0026#34; value=\u0026#34;Trevor\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input3\u0026#34; value=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input4\u0026#34; value=\u0026#34;Melissa\u0026#34;\u0026gt;    string을 하나 받고 첫번째 empty \u0026lt;input\u0026gt;에 넣는 setFirstEmptyInput() 함수를 작성하려 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var setFirstEmptyInput = function (new_value) { var found = false; var i = 1; var elem = document.getElementById(\u0026#39;input\u0026#39; + i); while (elem !== null) { if (elem.value === \u0026#39;\u0026#39;) { found = true; break; } i++; elem = document.getElementById(\u0026#39;input\u0026#39; + i); } if (found) elem.value = new_value; return elem; };    변수 관점 : var found, i, elem\n found 같은 intermediate variables는 미리 return   1 2 3 4 5 6 7 8 9 10 11 12 13 14  var setFirstEmptyInput = function (new_value) { var i = 1; var elem = document.getElementById(\u0026#39;input\u0026#39; + i); while (elem !== null) { if (elem.value === \u0026#39;\u0026#39;) { elem.value = new_value; return elem; } i++; elem = document.getElementById(\u0026#39;input\u0026#39; + i); } return null; };    elem은 loopy하게 쓰이는데 1부터 올라가는 순서로 바꿔써본다  1 2 3 4 5 6 7 8 9 10 11  var setFirstEmptyInput = function (new_value) { for (var i = 1; true; i++) { var elem = document.getElementById(\u0026#39;input\u0026#39; + i); if (elem === null) return null; // Search Failed. No empty input found. \tif (elem.value === \u0026#39;\u0026#39;) { elem.value = new_value; return elem; } } };   __요약  You can make your code easier to read by having fewer variables and making them as “lightweight” as possible. Specifically:  Eliminate variables that just get in the way. In particular, we showed a few examples of how to eliminate “intermediate result” variables by handling the result immediately. Reduce the scope of each variable to be as small as possible. Move each variable to a place where the fewest lines of code can see it. Out of sight is out of mind. Prefer write-once variables. Variables that are set only once (or const, final, or otherwise immutable) make code easier to understand.   "
},
{
	"uri": "https://klee30810.github.io/sci/",
	"title": "Science",
	"tags": [],
	"description": "",
	"content": "Chapter 9 Science Science Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap10/",
	"title": "Chap10. 상관없는 하위문제 추출",
	"tags": ["programming"],
	"description": "",
	"content": " 큰 흐름과 관계가 적은 하위 문제를 적극적으로 발견해서 추출하라.   주어진 함수나 코드 블록을 보고, 스스로에게 질문하라. \u0026quot;상위 수준에서 본 이 코드의 목적은 무엇인가?\u0026quot;\n 코드의 모든 줄에 질문을 던져라. \u0026quot;이 코드는 직접적으로 코드가 해결하기 위한 목적을 위해서 존재하는가?\n  혹은 그 목적을 위해서 필요하긴 하지만 그 자체와 직접적으로 상관없는 하위 문제를 해결하는가?\u0026quot;\n만약 본래 목적과 직접적으로 관련되지 않은 하위 문제를 해결하는 코드의 분량이 상당히 많으면, 이를 추출해서 별도의 함수로 만들어라.   이렇게 추출된 코드는 자신이 호출되는 이유를 알 필요가 없어야 한다.  __01. 소개를 위한 예: findClosestLocation() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Return which element of \u0026#39;array\u0026#39; is closest to the given latitude/longitude. // Models the Earth as a perfect sphere. var findClosestLocation = function (lat, lng, array) { var closest; var closest_dist = Number.MAX_VALUE; for (var i = 0; i \u0026lt; array.length; i += 1) { // Convert both points to radians. \tvar lat_rad = radians(lat); var lng_rad = radians(lng); var lat2_rad = radians(array[i].latitude); var lng2_rad = radians(array[i].longitude); // Use the \u0026#34;Spherical Law of Cosines\u0026#34; formula. \tvar dist = Math.acos(Math.sin(lat_rad) * Math.sin(lat2_rad) + Math.cos(lat_rad) * Math.cos(lat2_rad) * Math.cos(lng2_rad - lng_rad)); if (dist \u0026lt; closest_dist) { closest = array[i]; closest_dist = dist; } } return closest; };    예제 코드의 주요 목적은 주어진 점과 가장 가까운 장소를 찾는 것이다. 하지만 예제 안에 있는 대부분의 코드들이 '구 위에 있는 두 개의 위도/경도 점 사이의 거리를 계산한다'는 상위 문제와 상관없고 복잡하기만 한 하위 문제를 다룬다. 이런 코드는 별도의 함수로 따로 추출하는 편이 좋다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var spherical_distance = function (lat1, lng1, lat2, lng2) { var lat1_rad = radians(lat1); var lng1_rad = radians(lng1); var lat2_rad = radians(lat2); var lng2_rad = radians(lng2); // Use the \u0026#34;Spherical Law of Cosines\u0026#34; formula. \treturn Math.acos(Math.sin(lat1_rad) * Math.sin(lat2_rad) + Math.cos(lat1_rad) * Math.cos(lat2_rad) * Math.cos(lng2_rad - lng1_rad)); }; var findClosestLocation = function (lat, lng, array) { var closest; var closest_dist = Number.MAX_VALUE; for (var i = 0; i \u0026lt; array.length; i += 1) { var dist = spherical_distance(lat, lng, array[i].latitude, array[i].longitude); if (dist \u0026lt; closest_dist) { closest = array[i]; closest_dist = dist; } } return closest; };    별도의 함수로 추출하면 복잡한 하위 문제에 방해 받지 않고 상위 수준의 목적에 집중할 수 있으니 전반적인 코드의 가독성이 좋아진다. 또한 별도로 추출한 함수는 독립적인 테스트를 수행하는데도 유용하다.  __02. 순수한 유틸리티 코드  문자열 변경, 해시테이블 사용, 파일 읽기/쓰기와 같이 프로그램이 수행하는 일에는 매우 기본적인 작업을 포괄하는 핵심적인 집합이 있다. 이러한 '기본적인 유틸리티'는 대부분 해당 언어의 내장 라이브러리 안에 있다. 하지만 이런 작업을 수행하는 코드가 없어서 \u0026quot;라이브러리에 이런 함수가 있었으면 좋겠어!\u0026quot;라는 생각이 든다면 이를 함수로 작성하라. 이를 잘 정리해두면 다른 프로젝트에서도 사용할 수 있는 그럴듯한 유틸리티 코드 모음을 만들수 있다.  __03. 일반적인 목적의 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // dictionary example ajax_post({ url: \u0026#39;http://example.com/submit\u0026#39;, data: data, on_success: function (response_data) { var str = \u0026#34;{\\n\u0026#34;; for (var key in response_data) { str += \u0026#34; \u0026#34; + key + \u0026#34; = \u0026#34; + response_data[key] + \u0026#34;\\n\u0026#34;; } alert(str + \u0026#34;}\u0026#34;); // Continue handling \u0026#39;response_data\u0026#39; ... \t} }); // extracted function var format_pretty = function (obj) { var str = \u0026#34;{\\n\u0026#34;; for (var key in obj) { str += \u0026#34; \u0026#34; + key + \u0026#34; = \u0026#34; + obj[key] + \u0026#34;\\n\u0026#34;; } return str + \u0026#34;}\u0026#34;; };    예제 코드는 디버깅할 때 필요한 정보를 메시지 상자로 표시하는 목적을 수행하는데, 대부분의 코드가 이를 '예쁘게' 출력하는데 사용되고 있다. 이럴 때는 '예쁘게' 출력하는 부분만 따로 추출해서 함수로 만들 수 있다. 이렇게 하면 함수를 호출하는 코드를 간단하게 만들고, 이 함수를 다른 곳에서도 간편하게 사용할 수 있다는 장점이 있다. 또한 필요할 이 함수를 훨씬 손쉽게 개선할 수 있다는 장점도 있다. 별도로 분리된 작은 함수를 다룰 때는 기능을 더하고, 가독성을 개선하고, 코너케이스를 다루는 일이 상대적으로 쉽게 느껴지기 때문이다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Updated Version var format_pretty = function (obj, indent) { // Handle null, undefined, strings, and non-objects. \tif (obj === null) return \u0026#34;null\u0026#34;; if (obj === undefined) return \u0026#34;undefined\u0026#34;; if (typeof obj === \u0026#34;string\u0026#34;) return \u0026#39;\u0026#34;\u0026#39; + obj + \u0026#39;\u0026#34;\u0026#39;; if (typeof obj !== \u0026#34;object\u0026#34;) return String(obj); if (indent === undefined) indent = \u0026#34;\u0026#34;; // Handle (non-null) objects. \tvar str = \u0026#34;{\\n\u0026#34;; for (var key in obj) { str += indent + \u0026#34; \u0026#34; + key + \u0026#34; = \u0026#34;; str += format_pretty(obj[key], indent + \u0026#34; \u0026#34;) + \u0026#34;\\n\u0026#34;; } return str + indent + \u0026#34;}\u0026#34;; };   __04. 일반적인 목적을 가진 코드를 많이 만들어라  일반적인 코드는 프로젝트의 나머지 부분에서 완전히 분리되므로 개발하고, 테스트하고, 이해하기에 좋다. 프로젝트에서 사용하는 코드의 많은 부분이 이렇게 별도의 라이브러리로 만들어질 수 있다면 그렇게 하는 것이 좋다. 그렇게 하면 코드의 나머지가 차지하는 크기가 그만큼 줄어들어 프로그래머가 생각해야할 내용도 줄어들기 때문이다.  __05. 특정한 프로젝트를 위한 기능 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # Original business = Business() business.name = request.POST[\u0026#34;name\u0026#34;] url_path_name = business.name.lower() url_path_name = re.sub(r\u0026#34;[\u0026#39;\\.]\u0026#34;, \u0026#34;\u0026#34;, url_path_name) url_path_name = re.sub(r\u0026#34;[^a-z0-9]+\u0026#34;, \u0026#34;-\u0026#34;, url_path_name) url_path_name = url_path_name.strip(\u0026#34;-\u0026#34;) business.url = \u0026#34;/biz/\u0026#34; + url_path_name business.date_created = datetime.datetime.utcnow() business.save_to_database() # Extracted Version CHARS_TO_REMOVE = re.compile(r\u0026#34;[\u0026#39;\\.]+\u0026#34;) CHARS_TO_DASH = re.compile(r\u0026#34;[^a-z0-9]+\u0026#34;) def make_url_friendly(text): text = text.lower() text = CHARS_TO_REMOVE.sub(\u0026#39;\u0026#39;, text) text = CHARS_TO_DASH.sub(\u0026#39;-\u0026#39;, text) return text.strip(\u0026#34;-\u0026#34;) business = Business() business.name = request.POST[\u0026#34;name\u0026#34;] business.url = \u0026#34;/biz/\u0026#34; + make_url_friendly(business.name) business.date_created = datetime.datetime.utcnow() business.save_to_database()    추출된 하위 문제는 사용하는 프로젝트를 전혀 모르는 것이 가장 이상적이다. 하지만 그렇지 않아도 큰 상관은 없다. 특정한 프로젝트 내에서만 사용되는 하위 문제라도 이를 분리하는 것 만으로 큰 도움이 되기 때문이다.  __06. 기존의 인터페이스를 단순화하기  라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아한다. 적은 수의 인수를 받고, 별다른 설정을 요구하지 않으며, 사용하기 간편한 인터페이스가 좋다. 이러한 인터페이스는 코드를 우아하게 만들고, 동시에 간단하고 강력하게 만든다. 만약 자신이 사용하는 인터페이스가 이렇게 깔끔하지 않다면 깔끔한 '덮개(wrapper)'를 씌워서 보완할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13  var max_results; var cookies = document.cookie.split(\u0026#39;;\u0026#39;); for (var i = 0; i \u0026lt; cookies.length; i++) { var c = cookies[i]; c = c.replace(/^[ ]+/, \u0026#39;\u0026#39;); // remove leading spaces \tif (c.indexOf(\u0026#34;max_results=\u0026#34;) === 0) max_results = Number(c.substring(12, c.length)); } // TRANSFORMED var max_results = Number(get_cookie(\u0026#34;max_results\u0026#34;)); set_cookie(name, value, days_to_expire); delete_cookie(name);    우리는 이상적이지 않은 인터페이스를 그냥 받아들일 이유가 없다.  __07. 자신의 필요에 맞춰서 인터페이스의 형태를 바꾸기 1 2 3 4 5 6 7  user_info = { \u0026#34;username\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;...\u0026#34; } user_str = json.dumps(user_info) cipher = Cipher(\u0026#34;aes_128_cbc\u0026#34;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(user_str) encrypted_bytes += cipher.final() # flush out the current 128 bit block url = \u0026#34;http://example.com/?user_info=\u0026#34; + base64.urlsafe_b64encode(encrypted_bytes) ...    프로그램 안의 많은 코드들은 다른 코드를 지원하려고 존재한다.  1 2 3 4 5 6 7 8 9 10 11  // Changing Interface def url_safe_encrypt(obj): obj_str = json.dumps(obj) cipher = Cipher(\u0026#34;aes_128_cbc\u0026#34;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str) encrypted_bytes += cipher.final() # flush out the current 128 bit block return base64.urlsafe_b64encode(encrypted_bytes) //Then, the resulting code to execute the real logic of the program is simple: user_info = { \u0026#34;username\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;...\u0026#34; } url = \u0026#34;http://example.com/?user_info=\u0026#34; + url_safe_encrypt(user_info)    이와 같은 '접착(glue)'코드는 프로그램의 실제 논리와 별로 직접적인 상관이 없으므로 따로 분리하여 독자적인 함수로 만드는 것이 좋다. 이렇게 하면 프로그램이 수행하는 본래의 논리를 쉽게 파악할 수 있다.  __08. 지나치게 추출하기  코드에 새로운 함수를 더하는 일에는 분명히 가독성 비용이 든다. 만약 함수를 새로 만들면서 더해지는 가독성 비용이 이를 통해 얻는 이득보다 적다면 이를 수행할 이유가 없다. 새롭게 만든 작은 함수들이 다른 프로젝트에서도 사용된다면 추출하는 것이 이득이 되겠지만 그런 순간이 오기 전까지는 그럴 필요가 없다.  __요약  A simple way to think about this chapter is to separate the generic code from the project-specific code. As it turns out, most code is generic. By building a large set of libraries and helper functions to solve the general problems, what’s left will be a small core of what makes your program unique. The main reason this technique helps is that it lets the programmer focus on smaller, well-defined problems that are detached from the rest of your project. As a result, the solutions to those subproblems tend to be more thorough and correct. You might also be able to reuse them later.  +추가적인 읽기\n『리팩토링: 존재하는 코드의 설계를 개선하기(Refactoring: Improving the Design of Existing Code)』 - 마틴 파울러\n⇒ 여기서는 '메소드 추출' 기법과 다양한 코드 리팩토링 방법을 설명한다.\n『스몰토크 최선의 실전 패턴(Smalltalk Best Practice Patterns)』 - 켄트 벡\n⇒ 여기서는 코드를 잘개 쪼개서 수많은 함수로 구성하는 방법을 의미하는 '구성된 메소드 패턴(Composed Method Pattern)' 원리를 설명한다.\n⇒ 여기서 원리란 '모든 연산을 동일한 추상 수준의 메소드 안에 담기'를 말한다.\n"
},
{
	"uri": "https://klee30810.github.io/language/",
	"title": "Language",
	"tags": [],
	"description": "",
	"content": "Chapter 10 Language Languages Studies\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap11/",
	"title": "Chap11. 한 번에 하나씩",
	"tags": ["programming"],
	"description": "",
	"content": " 한 번에 여러 가지 일을 수행하는 코드는 이해하기 어렵다.  ★ 한 번에 하나의 작업만 수행하게 코드를 구성해야 한다. (코드를 '탈파편화(Defragmenting)'하라.)\n 하나의 함수는 오직 한 가지 작업만 하게 하는 것이 좋지만, 큰 함수를 독자적인 논리적 영역들로 재구성하는 것 만으로 가독성에 도움이 된다.\n 코드가 한 번에 한가지 일만 수행하게 하는 절차는 다음과 같다.\n   코드가 수행하는 모든 '작업'을 나열한다. 이때 작업은 아주 간단한 일일수도 있고, 아주 모호한 일일수도 있다.\n 이러한 작업을 분리하여 서로 다른 함수로 혹은 적어도 논리적으로 구분되는 영역에 놓을 수 있는 코드로 만들어라.\n  __01. 작업은 작을 수 있다 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var vote_changed = function (old_vote, new_vote) { var score = get_score(); if (new_vote !== old_vote) { if (new_vote === \u0026#39;Up\u0026#39;) { score += (old_vote === \u0026#39;Down\u0026#39; ? 2 : 1); } else if (new_vote === \u0026#39;Down\u0026#39;) { score -= (old_vote === \u0026#39;Up\u0026#39; ? 2 : 1); } else if (new_vote === \u0026#39;\u0026#39;) { score += (old_vote === \u0026#39;Up\u0026#39; ? -1 : 1); } } set_score(score); };    예제 코드는 투표 도구의 추천수를 바꾸는 작업을 하는 코드이다. 이때 한명의 사용자는 한 표만 행사할 수 있고 이를 수정할 수 있다.\n 이는 '사용자의 이전 투표값과 현재 투표값을 비교하는 작업'과 '점수를 변경하는 작업'으로 분리될 수 있다.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var vote_value = function (vote) { if (vote === \u0026#39;Up\u0026#39;) { return +1; } if (vote === \u0026#39;Down\u0026#39;) { return -1; } return 0; }; var vote_changed = function (old_vote, new_vote) { var score = get_score(); score -= vote_value(old_vote); // remove the old vote \tscore += vote_value(new_vote); // add the new vote  set_score(score); };    이렇게 각각의 작업을 분리하고 나면 코드를 더 읽기 편하게 만들 수 있다.  - 꼭 함수로 만들어서 분리하지 않더라도 두개의 논리적 영역으로 분류하는 것만으로도 가독성이 향상된다.\n__02. 객체에서 값 추출하기  예제 코드는 \u0026quot;도시,나라\u0026quot; 포맷으로 정보를 저장하는 코드이다.\n 이 코드에 입력되는 주소 값은 아래의 네가지이다.  'localityName(도시/마을)','SubAdministrativeAreaName(도시권/자치주)', 'AdministrativeAreaName(주/영역)', 'CountryName(나라명)'\n 이 예제의 문제점은 값들 중 일부 혹은 전체가 없을 수도 있다는 것이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var place = location_info[\u0026#34;LocalityName\u0026#34;]; // e.g. \u0026#34;Santa Monica\u0026#34; if (!place) { place = location_info[\u0026#34;SubAdministrativeAreaName\u0026#34;]; // e.g. \u0026#34;Los Angeles\u0026#34; } if (!place) { place = location_info[\u0026#34;AdministrativeAreaName\u0026#34;]; // e.g. \u0026#34;California\u0026#34; } if (!place) { place = \u0026#34;Middle-of-Nowhere\u0026#34;; } if (location_info[\u0026#34;CountryName\u0026#34;]) { place += \u0026#34;, \u0026#34; + location_info[\u0026#34;CountryName\u0026#34;]; // e.g. \u0026#34;USA\u0026#34; } else { place += \u0026#34;, Planet Earth\u0026#34;; } return place;    예제 코드에서는 비어있는 값을 다루기 위해서 기본값을 주는 방법을 사용했다.   '도시'를 선택할 때 값이 있으면 '도시/마을'을 사용한다. 만약 이 값이 없으면 '도시권/자치주'를 사용하고, 이도 없으면 '주/영역'을 사용한다. 세 값이 모두 없으면 '도시/마을'에 \u0026quot;Middle-of-Nowhere(아무 곳도 아닌 곳)'이라는 기본값을 준다. 만약 '나라'값이 없으면, 기본값으로 \u0026quot;Planet Earth(지구)\u0026quot;라는 값을 준다.   무작정 기본값을 주는 코드를 추가한 예제 코드는 지저분해졌고, 기능을 더 추가하면 더 지저분해질 상황이 되었다. 그래서 책에서는 '한 번에 한 가지 일' 원리를 적용하기 위해서 코드가 하는 일을 모두 정리했다.   location_info 딕셔너리에서 값들을 읽는다.  1 2 3 4  var town = location_info[\u0026#34;LocalityName\u0026#34;]; // e.g. \u0026#34;Santa Monica\u0026#34; var city = location_info[\u0026#34;SubAdministrativeAreaName\u0026#34;]; // e.g. \u0026#34;Los Angeles\u0026#34; var state = location_info[\u0026#34;AdministrativeAreaName\u0026#34;]; // e.g. \u0026#34;CA\u0026#34; var country = location_info[\u0026#34;CountryName\u0026#34;]; // e.g. \u0026#34;USA\u0026#34;   '도시'의 값을 설정하기 위해 정해진 선호도 순으로 값을 읽는다. 아무런 값도 찾을 수 없으면 \u0026quot;아무 곳도 아닌 곳\u0026quot;이라는 기본값을 설정한다.  1 2 3 4 5 6 7 8  // Start with the default, and keep overwriting with the most specific value. var second_half = \u0026#34;Planet Earth\u0026#34;; if (country) { second_half = country; } if (state \u0026amp;\u0026amp; country === \u0026#34;USA\u0026#34;) { second_half = state; }   '나라' 값을 설정한다. 값이 없으면 기본값인 \u0026quot;지구\u0026quot;로 설정한다.  1 2 3 4 5 6 7 8 9 10  var first_half = \u0026#34;Middle-of-Nowhere\u0026#34;; if (state \u0026amp;\u0026amp; country !== \u0026#34;USA\u0026#34;) { first_half = state; } if (city) { first_half = city; } if (town) { first_half = town; }   place를 변경한다.  1  return first_half + \u0026#34;, \u0026#34; + second_half;   \n- 코드를 리팩토링할 때 보통 여러 가지 접근 방법이 있다.\n- 일단 몇 가지 작업을 분리하면, 코드는 더 생각하기 쉬워지므로 이를 리팩토링 할 수 있는 더 나은 방법이 떠오르게 될 수도 있다.\n1 2 3 4 5 6 7 8 9  var first_half, second_half; if (country === \u0026#34;USA\u0026#34;) { first_half = town || city || \u0026#34;Middle-of-Nowhere\u0026#34;; second_half = state || \u0026#34;USA\u0026#34;; } else { first_half = town || city || state || \u0026#34;Middle-of-Nowhere\u0026#34;; second_half = country || \u0026#34;Planet Earth\u0026#34;; } return first_half + \u0026#34;, \u0026#34; + second_half;   __03. 더 큰 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // WARNING: DO NOT STARE DIRECTLY AT THIS CODE FOR EXTENDED PERIODS OF TIME. void UpdateCounts(HttpDownload hd) { // Figure out the Exit State, if available. \tif (!hd.has_event_log() || !hd.event_log().has_exit_state()) { counts[\u0026#34;Exit State\u0026#34;][\u0026#34;unknown\u0026#34;]++; } else { string state_str = ExitStateTypeName(hd.event_log().exit_state()); counts[\u0026#34;Exit State\u0026#34;][state_str]++; } // If there are no HTTP headers at all, use \u0026#34;unknown\u0026#34; for the remaining elements. \tif (!hd.has_http_headers()) { counts[\u0026#34;Http Response\u0026#34;][\u0026#34;unknown\u0026#34;]++; counts[\u0026#34;Content-Type\u0026#34;][\u0026#34;unknown\u0026#34;]++; return; } HttpHeaders headers = hd.http_headers(); // Log the HTTP response, if known, otherwise log \u0026#34;unknown\u0026#34; \tif (!headers.has_response_code()) { counts[\u0026#34;Http Response\u0026#34;][\u0026#34;unknown\u0026#34;]++; } else { string code = StringPrintf(\u0026#34;%d\u0026#34;, headers.response_code()); counts[\u0026#34;Http Response\u0026#34;][code]++; } // Log the Content-Type if known, otherwise log \u0026#34;unknown\u0026#34; \tif (!headers.has_content_type()) { counts[\u0026#34;Content-Type\u0026#34;][\u0026#34;unknown\u0026#34;]++; } else { string content_type = ContentTypeMime(headers.content_type()); counts[\u0026#34;Content-Type\u0026#34;][content_type]++; } }    이번 예제는 더 길고 복잡한 코드이다. 이 예제는 길고 복잡한만큼 실제로 많은 논리를 포함하며, 심지어 반복되는 코드도 있다. 이런 코드를 읽는 것은 결코 즐겁지 않다. 이 코드 전반에 걸쳐서 뒤섞여 있는 별도의 작업들은 다음과 같다.   각 키를 위한 기본값으로 \u0026quot;unknown\u0026quot; 사용하기.\n HttpDownload의 멤버 중 존재하지 않는 값이 있는지 확인하기.\n 값을 읽어서 문자열로 변환하기.\n counts[] 갱신하기.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void UpdateCounts(HttpDownload hd) { // Task: define default values for each of the values we want to extract \tstring exit_state = \u0026#34;unknown\u0026#34;; string http_response = \u0026#34;unknown\u0026#34;; string content_type = \u0026#34;unknown\u0026#34;; // Task: try to extract each value from HttpDownload, one by one \tif (hd.has_event_log() \u0026amp;\u0026amp; hd.event_log().has_exit_state()) { exit_state = ExitStateTypeName(hd.event_log().exit_state()); } if (hd.has_http_headers() \u0026amp;\u0026amp; hd.http_headers().has_response_code()) { http_response = StringPrintf(\u0026#34;%d\u0026#34;, hd.http_headers().response_code()); } if (hd.has_http_headers() \u0026amp;\u0026amp; hd.http_headers().has_content_type()) { content_type = ContentTypeMime(hd.http_headers().content_type()); } // Task: update counts[] \tcounts[\u0026#34;Exit State\u0026#34;][exit_state]++; counts[\u0026#34;Http Response\u0026#34;][http_response]++; counts[\u0026#34;Content-Type\u0026#34;][content_type]++; }    이렇게 작업을 정리하고 다시 작성한 코드는 다음과 같은 목적을 가진 세 개의 영역으로 분리되었다.   읽고자 하는 각각의 값을 위한 기본값을 정의한다. (우리가 관심을 가지고 있는 세 개의 키에 기본값을 설정한다.)\n HttpDownload에서 각각의 값을 하나씩 읽는다. (각 키에 대한 값이 존재하면 그 값을 읽어서 문자열로 변환한다.)\n count[]를 갱신한다. (각각의 키/값 짝에 counts[]를 갱신한다.)\n   처음에 나열한 작업이 네 개인데 실제 코드에는 세 개의 영역만 존재하는데 문제 될 것은 전혀 없다. 처음에 나열한 작업은 그저 출발점에 해당할 뿐이다. 나열된 대상 중에서 일부만 분리되어도 큰 도움이 된다. 이러한 개선은 별도로 함수를 만들지 않더라도 코드 정리를 도와준다. 예제에서는 처음에 별도의 함수를 만들지 않고 코드를 정리했다. 개선은 여러가지 방법으로 행할 수 있으며, 예제에서는 함수를 사용하는 방법도 따로 보여준다.  1 2 3 4 5 6 7 8 9 10 11 12 13  void UpdateCounts(HttpDownload hd) { counts[\u0026#34;Exit State\u0026#34;][ExitState(hd)]++; counts[\u0026#34;Http Response\u0026#34;][HttpResponse(hd)]++; counts[\u0026#34;Content-Type\u0026#34;][ContentType(hd)]++; } string ExitState(HttpDownload hd) { if (hd.has_event_log() \u0026amp;\u0026amp; hd.event_log().has_exit_state()) { return ExitStateTypeName(hd.event_log().exit_state()); } else { return \u0026#34;unknown\u0026#34;; } }    함수를 따로 정리한 예제 코드에는 중간 결과값을 저장하는 변수가 제거되었으며, 이는 9장과 관련이 있다. 두 해결책 모두 코드를 읽는 사람이 한 번에 하나의 일만 생각하게 하므로 가독성을 높여준다.  __요약  This chapter illustrates a simple technique for organizing your code: do only one task at a time. If you have code that’s difficult to read, try to list all of the tasks it’s doing. Some of these tasks might easily become separate functions (or classes). Others might just become logical “paragraphs” within a single function. The exact details of how you separate these tasks isn’t as important as the fact that they’re separated. The hard part is accurately describing all the little things your program is doing.  "
},
{
	"uri": "https://klee30810.github.io/indust/",
	"title": "Industry Analysis",
	"tags": [],
	"description": "",
	"content": "Chapter 11 Industrial Analysis Industrial Analysis\n"
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap12/",
	"title": "Chap12. 생각을 코드로 만들기",
	"tags": ["programming"],
	"description": "",
	"content": " 복잡한 생각을 다른 사람에게 설명할 때 중요하지 않은 자세한 내용 때문에 듣는 사람을 혼동시키는 일이 종종 있다.\n '쉬운 말'로 자신의 생각을 지식이 부족한 사람에게 전달하는 기술은 매우 중요하다.\n 여기에는 설명할 내용을 걸러서 요지만 뽑아내는 능력이 요구된다.\n  - 코드도 마찬가지로 '쉬운 말'로 작성되어야 한다.\n 이 장에서 설명할 코드를 더 명확하게 만드는 간단한 과정은 다음과 같다.   코드가 할 일을 다른 사람에게 설명하듯이 '쉬운 말'로 묘사하라.\n 이 설명에 들어가는 핵심적인 단어와 문구를 포착하라.\n 설명과 부합하는 코드를 작성하라.\n  __01. 논리를 명확하게 설명하기 1 2 3 4 5 6 7 8 9 10 11  $is_admin = is_admin_request(); if ($document) { if (!$is_admin \u0026amp;\u0026amp; ($document[\u0026#39;username\u0026#39;] != $_SESSION[\u0026#39;username\u0026#39;])) { return not_authorized(); } } else { if (!$is_admin) { return not_authorized(); } } // continue rendering the page ...    예제 코드는 '사용자가 페이지를 볼 수 있는 허가가 있는지를 확인하고, 만약 허가되어 있지 않으면 이를 설명하는 페이지를 반환한다.' 예제 코드를 쉬운 말로 묘사하면 다음과 같다.  사용이 허가되는 경우는 두가지다.\n 관리자다. 관리자는 아니지만 소유하고 있는 문서이다. 그렇지 않으면 허가되지 않는다.  1 2 3 4 5 6 7 8  if (is_admin_request()) { // authorized } elseif ($document \u0026amp;\u0026amp; ($document[\u0026#39;username\u0026#39;] == $_SESSION[\u0026#39;username\u0026#39;])) { // authorized } else { return not_authorized(); } // continue rendering the page ...    이를 이용해 수정한 예제 코드는 비어있는 본문 두개를 포함해서 조금 이상해보인다. 하지만 코드의 분량이 더 적고, 부정문이 없어서 논리도 더 간단해졌다. 즉, 더 이해하기 쉬워졌다.  __02. 라이브러리를 알면 도움이 된다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;div id=\u0026#34;tip-1\u0026#34; class=\u0026#34;tip\u0026#34;\u0026gt;Tip: Log in to see your past queries.\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;tip-2\u0026#34; class=\u0026#34;tip\u0026#34;\u0026gt;Tip: Click on a picture to see it close up.\u0026lt;/div\u0026gt; ... var show_next_tip = function () { var num_tips = $(\u0026#39;.tip\u0026#39;).size(); var shown_tip = $(\u0026#39;.tip:visible\u0026#39;); var shown_tip_num = Number(shown_tip.attr(\u0026#39;id\u0026#39;).slice(4)); if (shown_tip_num === num_tips) { $(\u0026#39;#tip-1\u0026#39;).show(); } else { $(\u0026#39;#tip-\u0026#39; + (shown_tip_num + 1)).show(); } shown_tip.hide(); };    간결한 코드를 작성하는 기술 중 하나는 라이브러리가 제공하는 기능을 잘 활용하는 것이다.  Describing the code : Find the currently visible tip and hide it. Then find the next tip after it and show that. If we've run out of tips, cycle back to the first tip.\n1 2 3 4 5 6 7 8 9  // SOLUTION var show_next_tip = function () { var cur_tip = $(\u0026#39;.tip:visible\u0026#39;).hide(); // find the currently visible tip and hide it \tvar next_tip = cur_tip.next(\u0026#39;.tip\u0026#39;); // find the next tip after it \tif (next_tip.size() === 0) { // if we\u0026#39;ve run out of tips, \tnext_tip = $(\u0026#39;.tip:first\u0026#39;); // cycle back to the first tip \t} next_tip.show(); // show the new tip };   __03. 논리를 쉬운 말로 표현하는 방법을 더 큰 문제에 적용하기 \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  def PrintStockTransactions(): stock_iter = db_read(\u0026#34;SELECT time, ticker_symbol FROM ...\u0026#34;) price_iter = ... num_shares_iter = ... # Iterate through all the rows of the 3 tables in parallel. while stock_iter and price_iter and num_shares_iter: stock_time = stock_iter.time price_time = price_iter.time num_shares_time = num_shares_iter.time # If all 3 rows don\u0026#39;t have the same time, skip over the oldest row # Note: the \u0026#34;\u0026lt;=\u0026#34; below can\u0026#39;t just be \u0026#34;\u0026lt;\u0026#34; in case there are 2 tied-oldest. if stock_time != price_time or stock_time != num_shares_time: if stock_time \u0026lt;= price_time and stock_time \u0026lt;= num_shares_time: stock_iter.NextRow() elif price_time \u0026lt;= stock_time and price_time \u0026lt;= num_shares_time: price_iter.NextRow() elif num_shares_time \u0026lt;= stock_time and num_shares_time \u0026lt;= price_time: num_shares_iter.NextRow() else: assert False # impossible continue assert stock_time == price_time == num_shares_time # Print the aligned rows. print \u0026#34;@\u0026#34;, stock_time, print stock_iter.ticker_symbol, print price_iter.price, print num_shares_iter.number_of_shares stock_iter.NextRow() price_iter.NextRow() num_shares_iter.NextRow()    예제 코드는 주식 구매현황을 기록하는 시스템이다. 각 거래는 다음의 네 가지 데이터 조각으로 포함한다.  time(구매의 정확한 날짜와 시간), ticker_symbol(예, GOOG), price(예, $600), number_of_share(예, 100)\n 문제는 이 값들이 시간과 세개의 값이 하나씩 포함된 세개의 서로 다른 테이블에 따로 존재하며 이를 합쳐야 한다는 것이다. 더 큰 문제는 어떤 행은 아예 존재하지 않으며, 존재하지 않는 행을 무시하면서 세 개의 테이블에서 time값이 동일한 행을 연결해야한다는 것이다. 이를 해결하기 위해 하려는 일을 쉬운 말로 묘사하면 다음과 같다.  세 개 반복자를 병렬적으로 동시에 읽는다. 어느 행의 time이 일치하지 않으면, 일치할 때 까지 앞으로 한칸씩 나아간다. 일치 된 행을 출력하고, 다시 앞으로 나아간다. 일치하는 행이 더 이상 없을 때 까지 이를 반복한다.\n 이 중 가장 지저분하게 작성되는 곳은 두 번째 줄이며 이를 함수로 분리할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def PrintStockTransactions(): stock_iter = ... price_iter = ... num_shares_iter = ... while True: time = AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter) if time is None: return # Print the aligned rows. print \u0026#34;@\u0026#34;, time, print stock_iter.ticker_symbol, print price_iter.price, print num_shares_iter.number_of_shares stock_iter.NextRow() price_iter.NextRow() num_shares_iter.NextRow()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter): # Iterate through all the rows of the 3 tables in parallel. while stock_iter and price_iter and num_shares_iter: stock_time = stock_iter.time price_time = price_iter.time num_shares_time = num_shares_iter.time # If all 3 rows don\u0026#39;t have the same time, skip over the oldest row if stock_time != price_time or stock_time != num_shares_time: if stock_time \u0026lt;= price_time and stock_time \u0026lt;= num_shares_time: stock_iter.NextRow() elif price_time \u0026lt;= stock_time and price_time \u0026lt;= num_shares_time: price_iter.NextRow() elif num_shares_time \u0026lt;= stock_time and num_shares_time \u0026lt;= price_time: num_shares_iter.NextRow() else: assert False # impossible continue assert stock_time == price_time == num_shares_time return stock_time    이 함수가 하는 작업을 다시 한번 쉬운 말로 묘사하면 다음과 같다.  각 테이블의 현재 행에서 time을 확인한다. 값이 모두 같으면 작업이 완료된 것이다. 그렇지 않으면 값이 '뒤쳐진' 행을 한 칸 전진시킨다. 행이 모두 동일한 time을 가질 때까지 혹은 반복자 중의 하나가 끝에 이를 때까지 작업을 반복한다\n 여기에서 주목할 부분은 이 설명이 우리가 해결하려는 상위 문제와 관련된 어떠한 사항도 언급하지 않는다는 점이다.\n 따라서 변수명을 더 간단하고 일반적이게 바꿀 수도 있다.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def AdvanceToMatchingTime(row_iter1, row_iter2, row_iter3): while row_iter1 and row_iter2 and row_iter3: t1 = row_iter1.time t2 = row_iter2.time t3 = row_iter3.time if t1 == t2 == t3: return t1 tmax = max(t1, t2, t3) # If any row is \u0026#34;behind,\u0026#34; advance it. # Eventually, this while loop will align them all. if t1 \u0026lt; tmax: row_iter1.NextRow() if t2 \u0026lt; tmax: row_iter2.NextRow() if t3 \u0026lt; tmax: row_iter3.NextRow() return None # no alignment could be found   __요약  자신의 문제를 쉬운 말로 설명할 수 없으면, 해당 문제는 무언가 빠져 있거나 아니면 제대로 정의되지 않은 것이다. This chapter discussed the simple technique of describing your program in plain English and using that description to help you write more natural code. This technique is deceptively simple, but very powerful. Looking at the words and phrases used in your description can also help you identify which subproblems to break off. But this process of “saying things in plain English” is applicable outside of just writing code. For example, one college computer lab policy states that when a student needs help debugging his program, he first has to explain the problem to a dedicated teddy bear in the corner of the room. Surprisingly, just describing the problem aloud can often help the student figure out a solution. This technique is called “rubber ducking.” Another way to look at it is this: if you can't describe the problem or your design in words, something is probably missing or undefined. Getting a program (or any idea) into words can really force it into shape.  "
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap13/",
	"title": "Chap13. 코드 분량 줄이기",
	"tags": ["programming"],
	"description": "",
	"content": " 프로그래머가 배워야 하는 가장 중요한 기술은 언제 코딩을 해야 하는지 아는 것이다.  ★ 가장 읽기 쉬운 코드는 아무것도 없는 코드다.\n__01. 그 기능을 구현하려고 애쓰지 마라 - 그럴 필요가 없다  프로그래머는 대개 프로젝트에 정말로 필요한 기능이 얼마나 있는지 과대평가하는 경향이 있다. 또한 어떤 기능을 구현하는 데 필요한 노력을 과소평가하는 경향도 있다. 이는 조잡한 프로토타입을 구현하는 시간을 지나치게 낙관적으로 에측하고, 그 코드를 장차 유지보수하고, 문서를 만들고, 코드 베이스에 새로운 '무게'를 더하는데 얼마나 많은 시간이 필요한지를 완전히 잊어버리게 한다.  __02. 요구사항에 질문을 던지고 질문을 잘게 나누어 분석하라  주어진 요구사항을 정말로 잘 분석하면, 적은 코드로 구현할 수 있는 간단한 문제를 정의할 수 있다. \u0026quot;요구사항을 제거하기\u0026quot;와 \u0026quot;더 간단한 문제를 해결하기\u0026quot;가 제공하는 이점은 아무리 강조해도 지나치지 않다.  __03. 코드베이스를 작게 유지하기  프로젝트를 처음 시작할 때는 한 두개의 소스 파일만 있으므로 관리하기 용이하나, 프로젝트가 커지면 이를 관리하는게 갈수록 어려워지기 마련이다. 이에 대처할 최선의 방법은 프로젝트가 성장하더라도 '코드베이스를 최대한 작고 가볍게 유지하는 것'이다.   일반적인 '유틸리티'를 많이 생성하여 중복된 코드를 제거하라.\n 사용하지 않는 코드 혹은 필요 없는 기능을 제거하라.\n 프로젝트가 서로 분절된 하위 프로젝트로 구성되게 하라.\n 코드베이스의 '무게'를 항상 의식하여 가볍고 날렵하게 유지시켜라.\n  __04. 자기 주변에 있는 라이브러리에 친숙해져라  프로그래머는 이미 존재하는 라이브러리로 자신의 문제를 풀 수 있는 상황이 많다는 걸 모르고 있다. 매일 15분씩 자신의 표준 라이브러리에 있는 모든 함수/모듈/형들의 이름을 읽어라. : These include the C++ Standard Template Library (STL), the Java API, the built-in Python modules, and others. 이는 라이브러리 전체를 암기하라는 것이 아니라 그 안에 무엇이 있는지 감을 잡아놓고 이후에 떠올릴 수 있게 하라는 뜻이다.  1 2 3 4 5 6 7 8 9 10  def unique(elements): temp = {} for element in elements: temp[element] = None # The value doesn\u0026#39;t matter. return temp.keys() unique_elements = unique([2,1,2]) /*-------------------------------*/ unique_elements = list(set([2,1,2])) # Remove duplicates    통계에 따르면 평균적인 수준의 소프트웨어 엔지니어는 출시할 수 있는 수준의 코드를 하루 평균 10줄 정도 작성한다고 한다. 여기에서 중요한 단어는 '출시할 수 있는 있는(shippable)'이라는 표현이다. 완숙한 라이브러리 안에 있는 모든 코드는 상당한 분량의 설계, 디버깅, 재작성, 문서화, 최적화, 테스트를 거쳤다.  __05. 예: 코딩 대신 유닉스 도구를 활용하기 1 2 3 4 5  1.2.3.4 example.com [24/Aug/2010:01:08:34] \u0026#34;GET /index.html HTTP/1.1\u0026#34; 200 ... 2.3.4.5 example.com [24/Aug/2010:01:14:27] \u0026#34;GET /help?topic=8 HTTP/1.1\u0026#34; 500 ... 3.4.5.6 example.com [24/Aug/2010:01:15:54] \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34; 404 ... ... // browser-IP host [date] \u0026#34;GET /url-path HTTP/1.1\u0026#34; HTTP-response-code ...    Unix  1 2 3 4 5 6 7 8 9 10  // UNIX cat access.log | awk \u0026#39;{ print $5 \u0026#34; \u0026#34; $7 }\u0026#39; | egrep \u0026#34;[45]..$\u0026#34; \\ | sort | uniq -c | sort -nr // Produces : \\ // 95 /favicon.ico 404 // 13 /help?topic=8 500 // 11 /login 403 // ... // \u0026lt;count\u0026gt; \u0026lt;path\u0026gt; \u0026lt;http response code\u0026gt;    \\we’ve avoided writing any “real” code or checking anything into source control.  __요약  다음과 같은 방법으로 새로운 코드를 작성하는 일을 피할 수 있다.   제품에 꼭 필요하지 않은 기능을 제거하고, '과도한 작업(overengineering)'을 피한다.\n 요구사항을 다시 생각해서, 가장 단순한 형태의 문제를 찾아본다.\n 주기적으로 라이브러리 전체 API를 훑어봄으로써 표준 라이브러리에 친숙해진다.\n  "
},
{
	"uri": "https://klee30810.github.io/compu/readable_code/chap14/",
	"title": "Chap14. 테스트와 가독성",
	"tags": ["programming"],
	"description": "",
	"content": " We’re going to focus on the readability aspect of tests and not get into whether you should write test code before writing real code (\u0026quot;test-driven development”) or other philosophical aspects of test development.  __01. 읽거나 유지보수하기 쉽게 테스트를 만들어라  Test code should be readable so that other coders are comfortable changing or adding tests.  __02. 이 테스트는 어떤 점이 잘못되었을까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Sort \u0026#39;docs\u0026#39; by score (highest first) and remove negative-scored documents. void SortAndFilterDocs(vector\u0026lt;ScoredDocument\u0026gt;* docs); void Test1() { vector\u0026lt;ScoredDocument\u0026gt; docs; docs.resize(5); docs[0].url = \u0026#34;http://example.com\u0026#34;; docs[0].score = -5.0; docs[1].url = \u0026#34;http://example.com\u0026#34;; docs[1].score = 1; 150 C H A P T E R F O U R T E E N docs[2].url = \u0026#34;http://example.com\u0026#34;; docs[2].score = 4; docs[3].url = \u0026#34;http://example.com\u0026#34;; docs[3].score = -99998.7; docs[4].url = \u0026#34;http://example.com\u0026#34;; docs[4].score = 3.0; SortAndFilterDocs(\u0026amp;docs); assert(docs.size() == 3); assert(docs[0].score == 4); assert(docs[1].score == 3.0); assert(docs[2].score == 1); }     There are at least eight different problems with this test code.  __03. 이 테스트를 더 읽기 쉽게 만들기  You should hide less important details from the user, so that more important details are most prominent. This test code clearly violates this rule. Every detail of the test is front and center, like the unimportant minutiae of setting up a vector. url, score, docs[] are just details about how the underlying C++ objects are set up, not about what this test is doing at a high level.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void MakeScoredDoc(ScoredDocument* sd, double score, string url) { sd-\u0026gt;score = score; sd-\u0026gt;url = url; } // Using this function, our test code becomes slightly more compact:  void Test1() { vector\u0026lt;ScoredDocument\u0026gt; docs; docs.resize(5); MakeScoredDoc(\u0026amp;docs[0], -5.0, \u0026#34;http://example.com\u0026#34;); MakeScoredDoc(\u0026amp;docs[1], 1, \u0026#34;http://example.com\u0026#34;); MakeScoredDoc(\u0026amp;docs[2], 4, \u0026#34;http://example.com\u0026#34;); MakeScoredDoc(\u0026amp;docs[3], -99998.7, \u0026#34;http://example.com\u0026#34;); ... }     The parameter \u0026quot;http://example.com\u0026quot; is just an eyesore. it’s just needed to fill out a valid ScoredDocument. Another unimportant detail we’re forced to see is docs.resize(5) and \u0026amp;docs[0], \u0026amp;docs[1], and so on.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void AddScoredDoc(vector\u0026lt;ScoredDocument\u0026gt;\u0026amp; docs, double score) { ScoredDocument sd; sd.score = score; sd.url = \u0026#34;http://example.com\u0026#34;; docs.push_back(sd); } // Using this function, our test code is even more compact: void Test1() { vector\u0026lt;ScoredDocument\u0026gt; docs; AddScoredDoc(docs, -5.0); AddScoredDoc(docs, 1); AddScoredDoc(docs, 4); AddScoredDoc(docs, -99998.7); ... }     Let’s describe what our test is trying to do in plain English (chapter 12) :  We have a list of documents whose scores are . After SortAndFilterDocs(), the remaining documents should have scores of [4, 3, 1], in that order.\n Nowhere in that description did we mention a vector.  1  ⇒ CheckScoresBeforeAfter(\u0026#34;-5, 1, 4, -99998.7, 3\u0026#34;, \u0026#34;4, 3, 1\u0026#34;);     In general, defining a custom minilanguage can be a powerful way to express a lot of information in a small amount of space. In this case, writing some helper functions to parse a comma-separated list of numbers shouldn’t be too hard.  1 2 3 4 5 6  void CheckScoresBeforeAfter(string input, string expected_output) { vector\u0026lt;ScoredDocument\u0026gt; docs = ScoredDocsFromString(input); SortAndFilterDocs(\u0026amp;docs); string output = ScoredDocsToString(docs); assert(output == expected_output); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  vector\u0026lt;ScoredDocument\u0026gt; ScoredDocsFromString(string scores) { vector\u0026lt;ScoredDocument\u0026gt; docs; replace(scores.begin(), scores.end(), \u0026#39;,\u0026#39;, \u0026#39; \u0026#39;); // Populate \u0026#39;docs\u0026#39; from a string of space-separated scores. \tistringstream stream(scores); double score; while (stream \u0026gt;\u0026gt; score) { AddScoredDoc(docs, score); } return docs; } string ScoredDocsToString(vector\u0026lt;ScoredDocument\u0026gt; docs) { ostringstream stream; for (int i = 0; i \u0026lt; docs.size(); i++) { if (i \u0026gt; 0) stream \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; stream \u0026lt;\u0026lt; docs[i].score; } return stream.str(); }       __04. 읽기 편한 에러 메시지 만들기  what happens when that assert(output == expected_output) line fails? It produces an error message like this:  1 2  Assertion failed: (output == expected_output), function CheckScoresBeforeAfter, file [test.cc](http://test.cc/), line 37.     Most languages and libraries have more sophisticated versions of assert()  1  BOOST_REQUIRE_EQUAL(output, expected_output)     BETTER ASSERT() IN OTHER LANGUAGES\n In Python, the built-in statement assert a == b produces a plain error message like:\n  1 2 3  File \u0026#34;[file.py](http://file.py/)\u0026#34;, line X, in \u0026lt;module\u0026gt; assert a == b AssertionError    Instead, you can use the assertEqual() method in the unittest module:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import unittest class MyTestCase(unittest.TestCase): def testFunction(self): a = 1 b = 2 self.assertEqual(a, b) if **name** == \u0026#39;**main**\u0026#39;: unittest.main() # which produces an error message like: File \u0026#34;[MyTestCase.py](http://mytestcase.py/)\u0026#34;, line 7, in testFunction self.assertEqual(a, b) AssertionError: 1 != 2    Whichever language you’re using, there’s probably a library/framework (e.g., XUnit) available to help you. It pays to know your libraries!\n Nicer Error Message\n  1 2 3 4  CheckScoresBeforeAfter() failed, Input: \u0026#34;-5, 1, 4, -99998.7, 3\u0026#34; Expected Output: \u0026#34;4, 3, 1\u0026#34; Actual Output: \u0026#34;1, 3, 4\u0026#34;   1 2 3 4 5 6 7 8 9 10  // Implementing!! void CheckScoresBeforeAfter(...) { ... if (output != expected_output) { cerr \u0026lt;\u0026lt; \u0026#34;CheckScoresBeforeAfter() failed,\u0026#34; \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; \u0026#34;Input: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; input \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; \u0026#34;Expected Output: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; expected_output \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; \u0026#34;Actual Output: \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; output \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; abort(); }    __05. 좋은 테스트 입력값의 선택  In general, you should pick the simplest set of inputs that completely exercise the code. A simpler value is just -1. (If -99998.7 was meant to be “a very negative number,” a better value would have been something crisp like -1e100.) Prefer clean and simple test values that still get the job done. Large inputs like these do a good job of exposing bugs such as buffer overruns or others you might not expect. But code like this is big and scary to look at and not completely effective in stress-testing the code. Instead, it’s more effective to construct large inputs programmatically, constructing a large input of (say) 100,000 values. Rather than construct a single “perfect” input to thoroughly exercise your code, it’s often easier, more effective, and more readable to write multiple smaller tests.  1 2 3 4 5  // four tests for SortAndFilterDocs(): CheckScoresBeforeAfter(\u0026#34;2, 1, 3\u0026#34;, \u0026#34;3, 2, 1\u0026#34;); // Basic sorting CheckScoresBeforeAfter(\u0026#34;0, -0.1, -10\u0026#34;, \u0026#34;0\u0026#34;); // All values \u0026lt; 0 removed CheckScoresBeforeAfter(\u0026#34;1, -2, 1, -2\u0026#34;, \u0026#34;1, 1\u0026#34;); // Duplicates not a problem CheckScoresBeforeAfter(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); // Empty input OK    __06. 테스트 함수에 이름 붙이기  Picking a good name for a test function can seem tedious and irrelevant, but don’t resort to meaningless names like Test1(), Test2(), and the like. Instead, you should use the name to describe details about the test. In particular, it’s handy if the person reading the test code can quickly figure out: • The class being tested (if any) • The function being tested • The situation or bug being tested possibly with a “Test_” prefix The test function name is effectively acting like a comment. Also, if that test fails, most testing frameworks will print out the name of the function where the assertion failed, so a descriptive name is especially helpful. When it comes to naming helper functions in your test code, it’s useful to highlight whether the function does any assertions itself or is just an ordinary “test-unaware” helper  __07. 이 테스트 코드는 무엇이 잘못되었는가? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void Test1() { vector\u0026lt;ScoredDocument\u0026gt; docs; docs.resize(5); docs[0].url = \u0026#34;http://example.com\u0026#34;; docs[0].score = -5.0; docs[1].url = \u0026#34;http://example.com\u0026#34;; docs[1].score = 1; docs[2].url = \u0026#34;http://example.com\u0026#34;; docs[2].score = 4; docs[3].url = \u0026#34;http://example.com\u0026#34;; docs[3].score = -99998.7; docs[4].url = \u0026#34;http://example.com\u0026#34;; docs[4].score = 3.0; SortAndFilterDocs(\u0026amp;docs); assert(docs.size() == 3); assert(docs[0].score == 4); assert(docs[1].score == 3.0); assert(docs[2].score == 1); }     The test is very long and full of unimportant details. You can describe what this test is doing in one sentence, so the test statement shouldn’t be much longer. Adding another test isn’t easy. You’d be tempted to copy/paste/modify, which would make the code even longer and full of duplication. The test failure messages aren’t very useful. If this test fails, it will just say Assertion failed: docs.size() == 3, which doesn’t give you enough information to debug it further. The test tries to test everything at once. It’s trying to test both the negative filtering and the sorting functionality. It would be more readable to break this into multiple tests. The test inputs aren’t simple. In particular, the example score -99998.7 is “loud” and gets your attention even though there isn’t any significance to that specific value. A simpler negative value would suffice. The test inputs don’t thoroughly exercise the code. For example, it doesn’t test when the score is 0. (Would that document be filtered or not?) It doesn’t test other extreme inputs, such as an empty input vector, a very large vector, or one with duplicate scores. The name Test1() is meaningless—the name should describe the function or situation being tested.  __08. 테스트에 친숙한 개발  Ideal code to test has a well-defined interface, doesn’t have much state or other “setup,” and doesn’t have much hidden data to inspect. You start designing your code so that it’s easy to test! Fortunately, coding this way also means that you create better code in general. Test-friendly designs often lead naturally to well-organized code, with separate parts to do separate things.  TEST-DRIVEN DEVELOPMENT Test-driven development (TDD) is a programming style where you write the tests before you write the real code. TDD proponents believe this process profoundly improves the quality of the nontest code, much more so than if you write the tests after writing the code.\nThis is a hotly debated topic that we won’t get into. At the very least, we’ve found that just keeping testing in mind while writing code helps make the code better.\nBut regardless of whether you employ TDD, the end result is that you have code that tests other code. The goal of this chapter is to help you make your tests easier to read and write.\n Of all the ways to break up a program into classes and methods, the most decoupled ones are usually the easiest to test.  \n\n__09. 지나친 테스트  Sacrificing the readability of your real code, for the sake of enabling tests. Designing your real code to be testable should be a win-win situation: your real code becomes simpler and more decoupled, and your tests are easy to write. But if you have to insert lots of ugly plumbing into your real code just so you can test it, something’s wrong. Being obsessive about 100% test coverage. Testing the first 90% of your code is often less work than testing that last 10%. That last 10% might involve user interface, or dumb error cases, where the cost of the bug isn’t really that high and the effort to test it just isn’t worth it. The truth is that you’ll never get 100% coverage anyhow. If it’s not a missed bug, it might be a missed feature or you might not realize that the spec should be changed. Depending on how costly your bugs are, there’s a sweet spot of how much development time it’s worth spending on test code. If you’re building a website prototype, it might not be worth writing any test code at all. On the other hand, if you’re writing a controller for a spaceship or medical device, testing is probably your main focus. Letting testing get in the way of product development. We’ve seen situations where testing, which should be just one aspect of a project, dominates the whole project. Testing becomes some sort of god to be appeased, and coders just go through the rituals and motions without realizing that their precious engineering time might be better spent elsewhere.  __요약  The top level of each test should be as concise as possible; ideally, each test input/output can be described in one line of code. If your test fails, it should emit an error message that makes the bug easy to track down and fix. Use the simplest test inputs that completely exercise your code. Give your test functions a fully descriptive name so it’s clear what each is testing. Instead of Test1(), use a name like Test_\u0026lt;FunctionName\u0026gt;_\u0026lt;Situation\u0026gt;.  "
},
{
	"uri": "https://klee30810.github.io/language/english/",
	"title": "English",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://klee30810.github.io/language/chinese/",
	"title": "Chinese",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://klee30810.github.io/tags/programming/",
	"title": "programming",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://klee30810.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://klee30810.github.io/tags/battery/",
	"title": "battery",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://klee30810.github.io/tags/overview/",
	"title": "overview",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://klee30810.github.io/paper_review/battery/goodenough2013/",
	"title": "The Li-Ion Rechargeable Battery: A Perspective",
	"tags": ["battery", "overview"],
	"description": "",
	"content": "The Li-Ion Rechargeable Battery: A Perspective  Author : Kyungmin Lee Thesis : Li-Ion Battery is hot trend of technology with its cathode, anode, electrolyte, and separation membrane. Citation : Goodenough, J. B., \u0026amp; Park, K. S. (2013). The Li-ion rechargeable battery: a perspective. Journal of the American Chemical Society, 135(4), 1167-1176.  Abstract   Each cell of a battery stores electrical energy as chemical energy in two electrodes, a reductant (anode) and an oxidant (cathode)  separated by an electrolyte that transfers the ionic component of the chemical reaction inside the cell and forces the electronic component outside the battery  The chemical reaction of a rechargeable battery must be reversible on the application of a charging I and V. Critical parameters of a rechargeable battery are safety, density of energy that can be stored at a specific power input and retrieved at a specific power output, cycle and shelf life, storage efficiency, and cost of fabrication Conventional rechargeable battery have solid electrode \u0026amp; liquid electrolyte The positive electrode (cathode) consists of a host framework into which the mobile (working) cation is inserted reversibly over a finite solid−solution range which limits the amount of charge per electrode formula unit and is reduced at higher current by the rate of transfer of the workding ion across the interfaces. the difference between energies of the LUMO and the HOMO of the electrolyte, i.e., electrolyte window, determines the maximum voltage for a long shelf and cycle life. Li-ion rechargeable battery uses an organic electrolyte with a larger window, which increase the density of stored energy Anode or cathode electrochemical potentials outside the electrolyte window can increase V, but they require formation of a passivating surface layer that must be permeable to Li+ and capable of adapting rapidly to the changing electrode surface area as the electrode changes volume during cycling. A passivating surface layer adds to the impedance of the Li+ transfer across the electrode/electrolyte interface and lowers the cycle life of a battery cell. Moreover, passivation layer on the anode robs Li from the cathode irreversibly. Improvement can be doen through by investigating and controlling electrode passivation layers, improving the rate of Li+ transfer across electrode/electrolyte interfaces, identifying electrolytes with larger windows while retaining a Li+ conductivity \\(σ_{Li} \u0026gt; 10^{-3}S cm^{-1}\\), synthesizing electrode morphologies that reduce the size of the active particles while pinning them on current collectors of large surface area accessible by the electrolyte, lowering the cost of cell fabrication, , designing displacement-reaction anodes of higher capacity that allow a safe, fast charge, and designing alternative cathode hosts Beyond approach : using electrode hosts with two-electron redox centers; replacing the cathode hosts by materials that undergo displacement reactions (e.g. sulfur) by liquid cathodes that may contain flow-through redox molecules, or by catalysts for air cathodes; developing a Li+ solid electrolyte separator membrane that allows an organic and aqueous liquid electrolyte on the anode and cathode sides, respectively, and imaginative morphologies  Introduction   Li-Ion rechaeable battery (LIB) : for how long a shelf and cycle life, with how rapid a response to a power outage or fluctuation in the grid, and with how large a capacity at a competitive cost? The output current I and/or time Δt to depletion of the stored energy in a battery can be increased by enlarging the area of the electrodes or connecting cells in parallel; the voltage V for a desired power P = IV by connecting cells in series. the management of the individual cells of a battery becomes more complex, as does the cost, the larger the number of cells needed for a given battery application.  Electrochemical Cells   An electrochemical cell consists of two electrodes, the anode and the cathode, separated by an electrolyte, having a reversible chemical reaction at two electrodes. The electrolyte may be a liquid or a solid. Solid electrolytes are used with gaseous or liquid electrodes; they may be used with solid electrodes, but solid−solid interfaces are problematic unless the solid electrolyte is a polymer or the solid electrodes are thin. Solid electrodes separated by a liquid electrolyte are kept apart by an electrolyte-permeable separator.  \n The electrolyte conducts the ionic component of the chemical reaction between the anode and the cathode, but it forces the electronic component to traverse an external circuit where it does work.\n Ionic mobility in the electrolyte is smaller than the electronic conductivity in a metal, so a cell has large-area electrodes separated by a thin electrolyte;\n metallic current collectors deliver electronic current from/to the redox centers of the electrodes to/from posts that connect to the external circuit.\n During discharge and charge, an internal battery resistance \\(R_b\\) to the ionic current \\(Ii = I\\) **reduces the output voltage \\(V{dis}\\)** from the open-circuit voltage \\(V_{oc}\\) by a polarization \\(η = I_{dis}Rb\\) and increases the voltage \\(V{ch}\\) required to reverse the chemical reaction on charge by an overvoltage \\(η = I_{ch}R_b\\):\n  \\[ V_{dis}=V_{oc}-η(q, I_{dis}) \\quad V_{dis}=V_{oc}+η(q,I_{ch}) 100 \\times \\frac{\\int^{Q_{ids}}_0V_{dis}(q)dq}{\\int^{Q_{ch}}_0V_{ch}(q)dq}\\quad Q=\\int^{\\triangle t}_0 Idt=\\int^Q_0dq\\]\n where q represents the state of charge, Q is the total charge per unit weight (Ah\\(kg^{-1}\\)) or per volume (Ah\\(L^{-1}\\)) \\(I=dq/dt\\) and Q(I) is the cell capacity for given I\n Q depends on I because the rate of transfer of ions across electrode/electrolyte interfaces becomes diffusion-limited at high currents. A diffusion-limited loss of the Li inserted into an electrode particle at a high rate of charge or discharge represents a reversible loss of capacity.\n However, changes in electrode volume, electrode−electrolyte chemical reactions, and/or electrode decomposition can cause an irreversible loss of capacity\n Electrode−electrolyte chemical reactions that result in the irreversible formation of a passivating solid−electrolyte interphase (SEI) layer on an electrode during an initial charge of a cell fabricated in a discharged state are distinguished from the irreversible capacity fade that may occur with cycling.\n The cycle life of a battery is the number of cycles until the capacity fades to 80% of its initial reversible value. Aside from cost and safety, are its density (specific and volumetric) of stored energy, its output power \\(P(q) = V(q)I_{dis}\\) for a given discharge current, and its calendar (shelf) life.\n The available energy stored in a fully charged cell depends on the discharge current\\(I_{dis}=dq/dt\\). The stored energy is the product of the average voltage and the capacity.\n  \\[ energy = \\int^{\\triangle}_0 IV(t)dt = \\int^Q_0 V(q)dq \\]\n The volumetric energy density is of particular interest for portable batteries, especially those that power hand-held or laptop devices. The tap density is a measure of the volume fraction of active particles in a cylinder after “tapping”,   The Challenge   these developments continue to request more operating cycles in electronic devices with thinner and lighter LIBs of higher stored energy After 1st LIB of Yoshino, The energy stored in a hand-held LIB has since been successfully increased to \u0026gt;3.0 Ah in the 18 650 cell now available. However, the volumetric energy density has been increased mainly by cell engineering; and sophisticated cell engineering, including the ability of the synthetic chemist to control the size and morphology of the active particles as well as the architecture of the current collectors, has almost reached its limits. Present LIB uses reversible Li extraction from an oxide host as the rechargeable cathode and into carbon or buffered spongy silicon or tin as the anode host. The capacity of an oxide host is limited to the reversible solid−solution range of Li in the cathode; and where a passivating layer forms on the anode during the first charge, the capacity is further reduced by an irreversible loss of Li from the cathode in the Li+-permeable SEI layer formed on the anode. The open-circuit voltage of a cell is the difference between the electrochemical potentials \\(μ_A\\) and \\(μC\\) of the anode and cathode: \\(V{OC}=(μ_A-μ_C)/e\\)  \n This voltage is limited by either the “window” of the electrolyte or the top of the anion-p bands of the cathode. The window of the electrolyte is the energy gap between its lowest unoccupied and highest occupied molecular orbitals (LUMO and HOMO) of a liquid electrolyte or the bottom of the conduction band and top of the valence band of a solid electrolyte.\n \\(μ_A \\) above the electrolyte LUMO reduces the electrolyte unless the anode−electrolyte reaction becomes blocked by the formation of a passivating SEI layer; similarly, a \\(μ_C\\) located below the HOMO oxidizes the electrolyte unless the reaction is blocked by an SEI layer.\n \\(μ_C\\) cannot be lowered below the top of the cathode anion-p bands, which may have an energy above the electrolyte HOMO.\n Since the practical HOMO of the organic liquid carbonate electrolytes used in LIBs is at 4.3 eV below \\(μ_A\\)(Li), the voltage of the simple \\(LiMO2\\) layered oxides is also self-limited by the energy of the top of the O-2p bands, Figure 2c. As a result, the original \\(Li{1-x}CoO_2\\) cathode evolves oxygen or inserts protons on removing Li+ beyond x = 0.55\n In the interval 0.50.55, the added itinerant holes become trapped in O-2p molecular orbitals of peroxide \\O_2^{2−}\\) ions at the particle surface, which is followed by \\(O_2\\) evolution. Not only is μC pinned at the top of the O-2p bands, it also becomes impossible to oxidize the Co beyond a Co(IV)/Co ratio of 0.55.\n investigation of these high-voltage cathodes has been limited because the organic liquid carbonate electrolytes used in the LIBs decompose at a voltage V \u0026gt; 5 V. Moreover, the counter cation used to lower the top of the O-2p bands reduces the capacity unless the active redox center can accommodate two electrons without a voltage step between them.\n  Rechargeable Li-Ion Batteries: Their Evolution   Reversible chemical reactions at solid electrodes are of two types: displacement and insertion reactions. Solid cathodes undergo insertion reactions, and solid anodes commonly undergo displacement reactions, but insertion reactions are also used\n insertion reactions consist of an electronically conducting host structure into/from which the working cation, e.g., H+ or Li+, can be inserted/extracted reversibly over a finite solid−solution range; e.g., the cathode reaction:\n  \\[ xH^+ xe^-+NiOOH = NiO_{1-x}(OH)_{1+x} \\]\n The anode of an aqueous-electrolyte battery may be either an insertion host, e.g., a metal hydride MHx, or an elemental metal that undergoes a displacement reaction  \\[ Cd+2xH_2O-2xe^- = Cd(OH)_2 + 2xH^+\\]\n The window of an aqueous electrolyte restricts the voltage of a battery with a stable shelf life to V ≤ 1.5V\n The Li-ion battery was motivated by the need for a rechargeable battery with a larger energy density, i.e., a larger voltage, which requires a nonaqueous electrolyte. Since H+ is only mobile in an aqueous medium, Li+ was chosen as the working ion in a nonaqueous electrolyte.\n Li with liquid carbonate offer a lower practical HOMO at ~ 4.3cV below Li., and primary\n  (unrechargeable) Li batteries with these electrolytes were known to support the anode displacement reaction, provided the the electrolyte included an ethylene carbonate (EC) additive to passivate the Li anode\n\\[ Li = Li_{1-x}+xLi^+xe^-\\]\n Unfortunately, although the SEI layer that forms with EC to passivate the Li anode is  permeable to Li+, it prevents uniform plating of Li during charge in a rechargeable cell. Consequently, dendrites form and, on repeated charging, can grow across the separator to give an internal short-circuit with incendiary, even explosive, consequences.\n However, the concept of a LIB was not abandoned. Goodenough recognized that increasing the voltage of the anode would require a cathode providing a larger voltage vs Li.\n Rachid Yazami was exploring Li intercalation into graphite and noted that reversible Li insertion into carbon avoids the problem of dendrite formation,\n The first Li-ion battery was assembled by Yoshino with a dischared carbon anode and a discharged LiCoO2\n  \\[ C+xe^-+xLi^+=Li_xC(anode) \\\\ LiCoO_2 -xe^- -xLi^+ = Li_{1-x}CoO_2(cathode)\\]\n Insertion of a guest Li+ into a layered host like TiS2, CoO2, or graphite was originally referred to as intercalation.\n Nevertheless, O2 evolution inside a cell creates safety problems unless the cell voltage is carefully managed. The addition of ∼10% Al3+ stabilizes the layered oxides against electrode/electrolyte interface reactions on Li extraction, but at the expense of capacity\n Another safety issue is internal short-circuits by Li penetration across the separator or by direct cathode and anode contact through a pinhole or thermal shrinkage. To eliminate this problem, a slurry of Al2O3 and a polymeric binder is coated on the separator to block Li-dendrite penetration.\n If the Fermi energy μA of the charged anode is above the LUMO of the electrolyte, which is the case with a carbon anode at 0.2 V vs Li, a fraction of the Li from the cathode is consumed irreversibly on the initial charge in the passivating Li+-permeable SEI layer that forms on the anode surfaces.\n Moreover, the SEI layer increases the impedance of Li+ transfer across the anode/electrolyte interface, and the SEI layer changes with successive cycling to contribute to a capacity fade.\n Since carbon has a limited capacity and Li is plated onto its surface in a fast charge, the carbon anode is being replaced by insertion into Si or alloys of Sn or Sb.\n However, a huge lattice expansion (∼300% for Si) on Li insertion requires that the active anode be assembled as small particles or a sponge-like array within a Li+ and electron conductive medium that is sufficiently elastic to absorb the volume changes.\n a μA ≤ 0.2 V vs Li does not allow safe fast charge that is desired for an electric vehicle battery. The buffering medium may be carbon or a conductive polymer. However, a μA(Li) − μA(alloy) \u0026lt;1.1 eV still requires formation of an SEI layer with the organic liquid-carbonate electrolyte\n In an attempt to improve the stability and lower the impedance of the SEI layer, replacement of EC by other additives to the electrolyte, e.g. fluoroethylene carbonate,22 is being explored.\n Kummer \u0026amp; Weber discovered fast 2D Na+ transport in Na2O·11Al2O3, which offered the possibility of a rechargeable battery with molten electrodes and a solid electrolyte, attempt to develop Na+ and Li+ electrolytes.\n The larger Na+ ion requires a relatively large 3D interstitial space. The Li+ ion, on the other hand, is small enough to be mobile at room temperature in a close-packed oxide-ion array, However, these 2D Li+ conductors have a degree of freedom along the c axis\n cooperative Jahn-Teller distortion : The e-orbital degeneracy on a localized Mn(III):t3e1 high-spin configuration in sufficient concentration gives rise to a cooperative orbital ordering to lower the Mn(III) site symmetry above room temperature.\n The Ni couples remain close enough to the top of the O-2p bands that the holes introduced into the σ-bonding 3d orbitals of Ni(II) occupy itinerant states of d-orbital symmetry\n Not only high Li+ mobility in the close-packed oxide-ion array of the spinel framework, but also that elimination of the anode SEI layer improves greatly the cycle life of the electrode.\n The FePO4 framework is inexpensive and environmentally friendly, but the cost of quality control of the LiFePO4 electrodes is presently too expensive.\n  → exposing the surface to S or N anions has been shown to lower the surface charge-transfer impedance, thereby increasing the capacity at higher rates of charge/discharge\n two-phase reaction between LiFePO4 and FePO4 gives a flat output voltage, but it prevents sufficient mixed valence on the iron in either phase to give an adequate polaronic conductivity.\n Therefore, it has proved necessary to either coat small particles of shorter charge-carrier path length with an electronically conductive surface layer and/or reduce the particle size to the nanoscale where a larger range of single-phase reaction occurs.\n  More detailed challenges go on the paper.... Strategies with Solid Electrolytes   Kummer and Weber23 proposed in 1967 the sodium−sulfur battery, which uses cells containing a solid electrolyte separating a molten Na anode and a cathode of molten sulfur impregnated by carbon felt  \\[ 2Na + FeCl_2 = 2NaCl + Fe \\]\n Sodium is much less expensive than lithium and widely available, but operation at higher temperatures of corrosive materials presents a challenge.\n On the other hand, solid electrolytes allow consideration of liquid and gaseous reactants.\n An all solid-state Li battery would, in principle, use an inorganic solid or a polymer Li+ electrolyte. An inorganic solid Li+ electrolyte has been used with thin solid electrodes in an all solid-state Li cell, but the volume changes in the electrodes on charge/discharge have not allowed retention of good electrode/electrolyte contact in a rechargeable storage battery\n Polymer Li+ electrolytes with a sufficiently large window and a Li+ conductivity \\(σ_{Li}\\) \u0026gt; 10−4 S cm−1 that retains a good contact with solid electrodes have yet to be demonstrated.\n a solid Li+ electrolyte membrane separating different liquid electrolytes contacting the anode and cathode would offer the possibility, if it blocked Li+ dendrites, of a lithium anode and a liquid or gaseous cathode reactant.\n However, a solid Li+ electrolyte separator that blocks dendrites from a Li anode would need to have a major ceramic component, but a sufficiently thin ceramic membrane would be too fragile.\n A practical solid-electrolyte separator membrane would need:\n  (a) a \\(σ_{Li}\\) \u0026gt; 10−4 S cm−1;\n(b) the capability to block Li dendrites without being reduced;\n(c) to be chemically stable in the liquid electrolytes;\n(d) to be easily fabricated into a mechanically robust, flexible thin membrane.\n These requirements would appear to require a ceramic-polymer composite\n Moreover, coating the surface of the electrolyte particles with a hydrophobic skin, e.g., polydopamine, allows Li+ transport while stabilizing the electrolyte particles in an aqueous electrolyte.\n The air cathode offers a high capacity, but the reversible reaction: requires inexpensive catalysts for the oxygen-reduction reaction (ORR) and the oxygen-evolution reaction (OER) at a high rate with a voltage difference Vch − Vdis ≤ 0.3 for storage efficiency\n \\[ 4Li^+ + 4e^- + O_2 = 2Li_2O \\]\n \\[ 4Li^+ + 4e^- +O_2=2Li_2O\\]\n With a solid Li+ electrolyte separator of a nonaqueous electrolyte at a Li anode and an aqueous electrolyte at the air cathode, the voltage can be increased to ∼3.5 V.\n The lithium−sulfur battery also provides a multielectron redox couple at the sulfur cathode and, therefore, a large increase in capacity\n A composite polymer gel containing a large volume fraction of an inorganic oxide and an organic liquid electrolyte immobilized in a polymer can give a flexible, thin membrane, but it needs yet to be tests for block dendrite from Li anode\n  Summary   Electrical energy can be stored efficiently in a rechargeable battery, and the shift from an aqueous to the organic liquid-carbonate electrolyte in a LIB increased the energy density of a rechargeable battery sufficiently to enable battery-powered hand-held electronic devices and power tools Realization of this vision has led to consideration of multiple-electron redox couples and/or multivalent working ions such as Mg2+ in place of Li+, the electrolyte, catalysts, and organic multiple-electron redox centers, potential of a Li+ electrolyte membrane separating two different liquid electrolytes, a material that will require a composite of a polymer and an inorganic Li+ electrolyte, 3D current collectors that enable thicker electrodes and flow-through liquid cathodes, electrochemical capacitors of higher energy density, Na-ion battery to eliminate vulnerability to sources of lithium and to lower material costs; however, the larger Na+ ion is adequately mobile only in framework oxides with a larger interstitial volume than is available in a close-packed oxide-ion array  "
},
{
	"uri": "https://klee30810.github.io/battery/battery-basics/",
	"title": "Battery Basics",
	"tags": [],
	"description": "",
	"content": "2차전지 기본개념 1. 개요  (1) 2차전지의 필요성  일상생활에 많이 쓰임 / 일회용 소모품의 낭비 / 폐기물 및 환경오염 리튬이온전지 : 가볍고 소형화 가능 / 규제물질(수은) X / 자연방전현상 小 / 3.7V 의 높은 출력  (2) 전지  전기에너지를 생성할 수 있는 화학에너지를 저장하는 장치, 산화\u0026amp;환원 작용   종류   망간: 일회용 건전지, 저렴 알칼리 : 수산화 칼륨 전해액, 장시간 사용가능 납 축전지 : 크고 무겁다 / 높은 전류와 외부 저항 낮음 ⇒ 차량용으로 널리 사용 산화 은: 가장 소형 \u0026amp; 저렴 (시계), 고온에서 잘 버팀  분류   2차전지(축전지, 충전지) : 전기 충전을 반복해 지속적으로 사용가능하도록 만듬  1차전지: 시간이 흐르며 전압이 낮아짐 2차전지 : 사용가능 시간까지 일정하게 전압이 유지되다가 방전시에 끊김   리튬전지 : 소형, 휴대용 → 3V 고압, 고밀도 에너지 + 양호한 보존성  음극에 금속 리튬 \u0026amp; 전해액에 유기용매 금속 Li는 이온화 경향이 커서 활성화 되어있으므로 물과 반응하면 수소가스를 방출하며 그 자체도 연소성   연료전지 : 화학적으로 에너지를 저장하고 연료를 소모하며 전력 생산  전해질을 녹임 물로 전류를 흘려보내 \\(H_2, O_2\\)발생 → 전해질로 사용하는 전극에 \\(H_2​\\), 산화전극에 \\(O_2\\)를 보내서 화학반응 유도 수소 연료와 산화제 ⇒ 배출열을 이용해 연료의 80%까지 에너지로 변환     태양전지 : 태양 빛에너지 광전효과로 전기 에너지 변환 커패시터 : 충,방전에 따른 성능 저하를 방지하고 이온 분자를 저장할 수 있는 전기 이중 충전지, 쉽게 열화되지 않는다   용량 : 방전되어 전류가 흐르지 않기까지 사용할 수 있는 전기에너지의 양    2차전지 재충전은 무한대로 할 수 있는게 아님: 전극의 열화로 용량이 줄어듦 ⇒ 실제 용량이 공칭 용량의 50%까지 충방전할 수 잇는 횟수\n  자기방전율 : 방치시 서서히 방전 ⇒ Mg (10) → alkali (5) → Li (2)\n   에너지 밀도 : 스마트폰 → 질량 당 \\(\\rho\\) / EV → 체적 당 \\(\\rho\\)  2. 2차전지 산업  (1) 리튬이온전지 개발  리튬 : 가장 경량 (작은 밀도), 전기 화학반응으로 가장 높은 전압 방출, 메모리 효과 없음 / 반응성이 커서 폭발의 위험 존재  양극집전체 : Al 금속 산화물 양극 : \\(LiCoO_2, LiFePO_4\\) 전해액 : 리튬 소금계열 분리막 : 폴리에틸렌, 폴리프로필렌 음극 : 흑연(Graphite) 음극집전체 : \\(Cu\\)   충전 : Li+ 가 (+) → (-)로 흐름 / 양극 전자와 Li+는 외부 전압으로 인해 음극으로 이동되며 전압차 발생 방전 : 음극의 Li+ 가 (+)로 흐름 / 전위차가 있으므로 도선을 타고 음극 전자가 양극으로 흐름 \u0026amp; 전해액을 통해 Li+가 (+)이동 소형 배터리 : IT제품 + 가전제품 + EV (원형배터리) ESS : 저장장치, 전기에너지가 수요가 많거나 비쌀 때 사용 ⇒ 스마트 그리드 자동차 배터리 : 기술과 질적으로 앞섬 (중국은 95% 이상이 자국 제품용)    BMS (Battery Management System) : 배터리 모니터링 \u0026amp; 충방전 제어\n  PCS (Power Conversion System) : 저장, 방출을 위한 전기특성 (주파수, 전압, 교류) 조절\n  EMS (Energy Management System) : 컨트롤 센터에서 ESS 모니터링 \u0026amp; 제어\n  (2) 전기자동차  연료 폭발로 인한 소음 無, 엔진 왕복운동을 회전으로 바꿀 일이 없어 진동 無, 회전수로 속도 조절 \u0026amp; 일정하게 높은 토크 ⇒ 변속기 無   완속(AC)/급속(DC) 충전기, 컨버터(350V→12V), 인버터(DC→AC, AC의 freq로 모터 조절), 감속기 (회전수 \u0026amp; 토크), 배터리팩    HEV : 저속, 시동 시 전기, 감속시 발전(에너지 회생 모드), 엔진 메인\n  PHEV : 전기 메인, 연비 + 주행거리, 배터리 없어도 기름으로 구동\n  EV : 엔진과 연료탱크 無 ⇒ 차체 단순화 \u0026amp; 소음 無\n  3. 2차전지 4대 소재  1. 양극재  리튬이온을 제공하는 소스 배터리의 용량과 전압 결정 ⇒ 배터리 성능 \u0026amp; 특성 결정 LCO, NCM, NCA, LMO, LFP   가장 원가비중 大, 에너지 밀도를 높이기 위해 니켈금속(충방전시 입자 균열 큼) 함유량 증가 / 안전성 小 Cobalt : 가격변동 大, 5% 미만시 성능 하락  2. 음극재  양극의 Li+를 흡수, 방출하며 외부 회로로 전류를 흐르게 함 ⇒ 안정성 흑연 : 안정된 구조 \u0026amp; 낮은 화학 반응성 ⇒ Li+를 많이 저장  3. 전해액  Li+의 이동 매개체 양, 음극 사이 Li+만 이동하도록 함 ⇒ 이온의 전도성 보장  4. 분리막  양, 음극 접촉 X PE의 미세한 구멍으로 Li+ 이동  4. 2차전지 제품  (1) 기초  충전 : 외부 전기에너지 인가 → 활물질의 포텐셜에너지 증가 → Li+는 전해액으로 이탈 \u0026amp; 전자는 도선으로 이탈 → 음극으로 이동 충방전시 산화(e- 증가), 환원(e- 감소)이 동시에 일어남 표준환원전위 : 물질의 고유한 전위차 ⇒ Li+가 가장 큼  (2) 설계 1) 주요 구성물질  양극 활물질 : Li함유, 불안정해서 산화물과 함꼐 사용 ⇒ 활물질 + 도전제(전도성 증가) + 바인더 → Li+활용량 증가 \u0026amp; 강한 결합에너지(이온화 에너지) 음극 활물질 : (+)에서 이동해 온 Li+의 가역적 저장 및 방출로 외부 회로를 통해 전류를 흐르게 함 ⇒ 이동 된 Li+를 얼마나 저장되느냐  충전 시 Li+는 (-)에 있고 도선시 자연스럽게 방전 흑연 : 안정적, 반응성 낮음, Li+ 저장량 大   전해액 : Li+의 이동통로, 전도가 높은 유기물 사용 (극성 有)  이온 전도도 高 \u0026amp; 전극에 대한 안전성 \u0026amp; 온도 범위(20~60\\(^oC) \u0026amp; 연소안전성 염(Li+ 이동 통로) + 용매 (염을 용해) + 첨가제   분리막 : 양극 활물질 접촉 제한 \u0026amp; Li+ 이동통로  온도 상승시 접촉을 막는 열적 수축 특성 필요 → PE, PP 충분한 밀착 필요    2) 구성 원리  많은 에너지 저장을 위한 다층구조 (양극-분리막-음극 ⇒ Jelly Roll) 와인딩 \u0026amp; 스택  3) 2차전지 설계  충방전시 양극의 총 전하량과 음극의 총 전하량은 동일 전지전압은 충방전량에 비례 설계전위 이상 전압을 보일 수 없음 음극이 양극보다 가역용량이 더 커야함  리튬석출: 충전시 음극에 저장되지 않는 Li+형성, 나중에 음극과 접촉하여 쇼트 발생   SEI (Solid Electrolyte Interphase) 막  음극 활물질 표면의 피막 전자의 이동을 제한하여 추가적 전기분해 방지 (전해액 소모 방지)   분극 : 실제 전압은 낮게 나오고 충전시 전압은 더 높게 나옴 → 내부 저항에 따른 과전압 형성 or 부위별 Li+ 농도 차이  (3) 제품 1) 셀/모듈/팩  셀: 기본 최소 단위 모듈 : 셀이 모인 플랫폼 팩 : 제품에 맞는 특성 + BMS (정확한 배터리 상태 해석)   BMS : 장시간 사용시에도 안정성   다수의 셀을 장시간 사용시 용량 변질 \u0026amp; 각 셀별 스펙이 달라짐  ⇒ 과전압, 과충전 가능 : 셀별 전압 detecting\n 필요 이상의 전류/전압을 방지하기 위한 보호회로 장착  (4) 신뢰성 \u0026amp; 안전성 1) 저온 \u0026amp; 고온  저온 : 용량 감소 (IT : \\(-10^oC\\), EV: \\(-30^oC\\) → 전해액의 mobility 감소 → 내부저항 증가 고온 : 용량 감소 → 전해액의 부피 팽창으로 mobility 증가 상쇄  2) 수명특성  특정 용량까지 도달하는데 전지가 충방전을 얼마나 많이 할 수 있는 지횟수 사이클 특성 : 충방전 회수 → 충방전 조건의 병기 必  급속한 경우 : 리튬금속 설축 or 전극판의 균일성 무너뜨림   율속(C-rate) : 전지 충방전시의 속도, 충방전시의 방전 전류의 변화  1.0C 충전 : 전지 만충까지 1시간 충전 / 0.5C 방전 : 100% 용량을 30분반에 방전 전동공구,청소기 : 10C↑, EV : 40C↑, 시동용 전지 : 100C↑ 활물질 + 극판설계 : 이온의 path를 줄여야!    3) 안전성  외부단락 (External Short) : 상온단락, 고온단락, 물속 투입 전기적 오사용 (Electric Abuse) : 과충전, 연속충전, 고율 충전 → 팩에서 평가 기계적 오사용 (Mechanical Abuse) : 관통, 압축, 낙하 열적 오사용 (Thermal Abuse) : 열노출, 열파편비산, 열파편관통  5. 2차전지의 미래  (1) 소재 : (+) 38%, (-) 12%, 분리막 13%, 전해질 11%  음극재, 전해액 : 기술장벽 低 → 50% 이상 중국 분리막 : 기술장벽 高 → 70% 일본 양극 활물질 : 고용량 → NCM, NCA ⇒ 비싼 Cobalt 줄이기 음극 활물질 : 동일한 물질에서 Li+ 많이 보관 \u0026amp; 부피 팽창 줄이기   리튬금속 : 안전성 低, 실리콘 : 300% 팽창  (2) 전고체전지 : 열로 인한 전해액 팽창 \u0026amp; 고온 시 발화 ⇒ 안전 \u0026amp; 고용량 / 유해가스 + 계면저항 高\n(3) 나트륨전지 : Li+ 대체용 ⇒ 같은 알칼리 계열이므로 비슷한 화학적 성질 6. 2차전지 생산/제조  (1) 개요  극판공정 : 양극 \u0026amp; 음극 활물질을 집전체에 코팅하여 필요한 폭으로 slitting 한 후 건조된 상태로 제작 조립공정 : 극판을 알맞게 재단 후 보관 케이스에 삽입, 전해액 주입 후 골고루 분산되도록 에이징 화성공정 : 충방전을 통해 설계된 전압과 용량이 구현하는지 확인하고 불량 검출 → 최초 충전시 음극 표면 SEI막 형성  (2) 세부사항 1) 극판공정  약품조합(Mixing) → 코팅(Coating)→프레싱(Pressing)→슬리팅(Slitting)→건조(Drying)  Mixing: 활물질을 집전체 표면에 코팅하기 위해 접착력을 위한 Binder 첨가 \u0026amp; 도전체 특성을 위한 도전체 첨가 ⇒ 필요한 점도와 분산성 달성 Coating : (+)활물질은 Al금속집전체, (-)활물질은 구리금속집전체 → 집전체 양면 코팅 \u0026amp; 건조 Pressing : 흡착력 강화를 위한 프레싱 \u0026amp; 부피감소 + 지속사용에 따른 수명특성 ↑ Slitting : 전지 높이 맞게 절단, 가로방향 절단 Drying : 수분 및 기타 불순물 제거    2) 조립 공정   극판을 케이스에 넣고 전해액을 투입해 전지 형태를 갖추는 단계\n  와인딩\n 극판을 양극-분리막-음극의 순서대로 배열 후 필요한 두께만큼 감아주는 방식 활물질이 길이 방향으로 코팅이 단절되어 있고 코팅 길이가 총 길이에 해당 비 코팅부에 도전으로 전자가 이동하도록 탭 용접    스택\n 극판을 설계치대로 절단된 양극-분리막-음극으로 적층 무정형 구조에 적용 가능 노칭 공정으로 양/음극 극판을 형상에 맞도록 slitting 후, 분리막을 지그재그로 적층하여 사이에 양/음극 투입 양/음극 각 극판에 단자 연결부가 있으며, 여러 층이 겹치면 극판 간 연결된 상태가 아니므로 극판 간 단자부를 연결하여 전류가 흐름    젤리롤의 케이스\n 캔타입: 삽입 후 상부 커버와 양/음극 단자를 연결하고 조립, 용접으로 밀봉 후 전해액 주입 파우치타입 : 평면의 파우치를 금형으로 젤리롤 방에 삽입 → 반대편 용접 \u0026amp; 파우치를 젤리롤보다 크게 하여 Pre-charging시 전해액 분해로 인한 가스 포집의 가스방 형성 → 조립 전 배출 후 최종 과정에서 제거 → 전해액 투입 →에이징    3) 화성 공정  조립 완료 전지에 전기에너지를 인가 해 Li+ 를 (-)로 이동시켜 전지 기능 확인   Pre-charging : 음극 표면 SEI막이 중요한 역할 Degassing : SEI 막 생성 중 전해액 분해의 가스 배출 Folding : Degas 후 파우치 끝을 접어 sealing 면이 나오지 않고 부피 ↓ Pressing : 물리적 흡착으로 부품 파손 방지 + 설계값이 두께 조절 Charging / Discharging : 마지막 충방전 확인 \u0026amp; 불량품  (3) 전지 제조 공법 비교  원통형은 와인딩 / 아닌 형태는 와인딩 or 스택    와인딩 : 회전시키며 극판을 감아주면 완성 → 생산성 ↑ → 설비 투자 ↓ ⇒ 원통, 사각형은 생산 가능\n  스택 : 다각형 전지 자유롭게 설계 \u0026amp; 성능 및 품질 면 유리\n  References   렛유인 2차전지 기초 [https://www.heybrandonkim.com/?p=1833](  "
},
{
	"uri": "https://klee30810.github.io/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Davinci Codex taken in Davince Museum in Popolo Square, Rome, Italy  Kevin\u0026rsquo;s Codex  😀 Leonardo Da Vinci\u0026rsquo;s studies in science and engineering are sometimes considered as impressive and innovative as his artistic work. These studies were recorded in 13,000 pages of notes and drawings, which fuse art and natural philosophy (the forerunner of modern science). They were made and maintained daily throughout Leonardo\u0026rsquo;s life and travels, as he made continual observations of the world around him.\n (Retrieved from Wikipedia \u0026ldquo;Leonardo Da Vinci\u0026rdquo;) 😃   아는 만큼 보이고 적는 만큼 이해한다  제가 배우는 모든 것에 대한 지식의 영속성을 위하여 기록으로 남깁니다!  Details about the author is in kmlee.xyz\n"
},
{
	"uri": "https://klee30810.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
}]